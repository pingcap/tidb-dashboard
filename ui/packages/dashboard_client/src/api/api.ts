// tslint:disable
/**
 * Dashboard API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from 'url'
import { Configuration } from './configuration'
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base'

/**
 *
 * @export
 * @interface ClusterinfoAlertManagerInfo
 */
export interface ClusterinfoAlertManagerInfo {
  /**
   *
   * @type {string}
   * @memberof ClusterinfoAlertManagerInfo
   */
  binary_path?: string
  /**
   *
   * @type {string}
   * @memberof ClusterinfoAlertManagerInfo
   */
  ip?: string
  /**
   *
   * @type {number}
   * @memberof ClusterinfoAlertManagerInfo
   */
  port?: number
}
/**
 *
 * @export
 * @interface ClusterinfoClusterInfo
 */
export interface ClusterinfoClusterInfo {
  /**
   *
   * @type {ClusterinfoAlertManagerInfo}
   * @memberof ClusterinfoClusterInfo
   */
  alert_manager?: ClusterinfoAlertManagerInfo
  /**
   *
   * @type {ClusterinfoGrafanaInfo}
   * @memberof ClusterinfoClusterInfo
   */
  grafana?: ClusterinfoGrafanaInfo
  /**
   *
   * @type {ClusterinfoClusterInfoPd}
   * @memberof ClusterinfoClusterInfo
   */
  pd?: ClusterinfoClusterInfoPd
  /**
   *
   * @type {ClusterinfoClusterInfoTidb}
   * @memberof ClusterinfoClusterInfo
   */
  tidb?: ClusterinfoClusterInfoTidb
  /**
   *
   * @type {ClusterinfoClusterInfoTikv}
   * @memberof ClusterinfoClusterInfo
   */
  tikv?: ClusterinfoClusterInfoTikv
}
/**
 *
 * @export
 * @interface ClusterinfoClusterInfoPd
 */
export interface ClusterinfoClusterInfoPd {
  /**
   *
   * @type {string}
   * @memberof ClusterinfoClusterInfoPd
   */
  err?: string
  /**
   *
   * @type {Array<ClusterinfoPDInfo>}
   * @memberof ClusterinfoClusterInfoPd
   */
  nodes?: Array<ClusterinfoPDInfo>
}
/**
 *
 * @export
 * @interface ClusterinfoClusterInfoTidb
 */
export interface ClusterinfoClusterInfoTidb {
  /**
   *
   * @type {string}
   * @memberof ClusterinfoClusterInfoTidb
   */
  err?: string
  /**
   *
   * @type {Array<ClusterinfoTiDBInfo>}
   * @memberof ClusterinfoClusterInfoTidb
   */
  nodes?: Array<ClusterinfoTiDBInfo>
}
/**
 *
 * @export
 * @interface ClusterinfoClusterInfoTikv
 */
export interface ClusterinfoClusterInfoTikv {
  /**
   *
   * @type {string}
   * @memberof ClusterinfoClusterInfoTikv
   */
  err?: string
  /**
   *
   * @type {Array<ClusterinfoTiKVInfo>}
   * @memberof ClusterinfoClusterInfoTikv
   */
  nodes?: Array<ClusterinfoTiKVInfo>
}
/**
 *
 * @export
 * @interface ClusterinfoGrafanaInfo
 */
export interface ClusterinfoGrafanaInfo {
  /**
   *
   * @type {string}
   * @memberof ClusterinfoGrafanaInfo
   */
  binary_path?: string
  /**
   *
   * @type {string}
   * @memberof ClusterinfoGrafanaInfo
   */
  ip?: string
  /**
   *
   * @type {number}
   * @memberof ClusterinfoGrafanaInfo
   */
  port?: number
}
/**
 *
 * @export
 * @interface ClusterinfoPDInfo
 */
export interface ClusterinfoPDInfo {
  /**
   *
   * @type {string}
   * @memberof ClusterinfoPDInfo
   */
  deploy_path?: string
  /**
   *
   * @type {string}
   * @memberof ClusterinfoPDInfo
   */
  ip?: string
  /**
   *
   * @type {number}
   * @memberof ClusterinfoPDInfo
   */
  port?: number
  /**
   *
   * @type {number}
   * @memberof ClusterinfoPDInfo
   */
  start_timestamp?: number
  /**
   *
   * @type {number}
   * @memberof ClusterinfoPDInfo
   */
  status?: number
  /**
   *
   * @type {string}
   * @memberof ClusterinfoPDInfo
   */
  version?: string
}
/**
 *
 * @export
 * @interface ClusterinfoTiDBInfo
 */
export interface ClusterinfoTiDBInfo {
  /**
   *
   * @type {string}
   * @memberof ClusterinfoTiDBInfo
   */
  binary_path?: string
  /**
   *
   * @type {string}
   * @memberof ClusterinfoTiDBInfo
   */
  ip?: string
  /**
   *
   * @type {number}
   * @memberof ClusterinfoTiDBInfo
   */
  port?: number
  /**
   *
   * @type {number}
   * @memberof ClusterinfoTiDBInfo
   */
  start_timestamp?: number
  /**
   *
   * @type {number}
   * @memberof ClusterinfoTiDBInfo
   */
  status?: number
  /**
   *
   * @type {number}
   * @memberof ClusterinfoTiDBInfo
   */
  status_port?: number
  /**
   *
   * @type {string}
   * @memberof ClusterinfoTiDBInfo
   */
  version?: string
}
/**
 *
 * @export
 * @interface ClusterinfoTiKVInfo
 */
export interface ClusterinfoTiKVInfo {
  /**
   *
   * @type {string}
   * @memberof ClusterinfoTiKVInfo
   */
  binary_path?: string
  /**
   *
   * @type {string}
   * @memberof ClusterinfoTiKVInfo
   */
  ip?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ClusterinfoTiKVInfo
   */
  labels?: { [key: string]: string }
  /**
   *
   * @type {number}
   * @memberof ClusterinfoTiKVInfo
   */
  port?: number
  /**
   *
   * @type {number}
   * @memberof ClusterinfoTiKVInfo
   */
  start_timestamp?: number
  /**
   *
   * @type {number}
   * @memberof ClusterinfoTiKVInfo
   */
  status?: number
  /**
   *
   * @type {number}
   * @memberof ClusterinfoTiKVInfo
   */
  status_port?: number
  /**
   *
   * @type {string}
   * @memberof ClusterinfoTiKVInfo
   */
  version?: string
}
/**
 *
 * @export
 * @interface DecoratorLabelKey
 */
export interface DecoratorLabelKey {
  /**
   *
   * @type {string}
   * @memberof DecoratorLabelKey
   */
  key: string
  /**
   *
   * @type {Array<string>}
   * @memberof DecoratorLabelKey
   */
  labels: Array<string>
}
/**
 *
 * @export
 * @interface DiagnoseGenerateReportRequest
 */
export interface DiagnoseGenerateReportRequest {
  /**
   *
   * @type {number}
   * @memberof DiagnoseGenerateReportRequest
   */
  compare_end_time?: number
  /**
   *
   * @type {number}
   * @memberof DiagnoseGenerateReportRequest
   */
  compare_start_time?: number
  /**
   *
   * @type {number}
   * @memberof DiagnoseGenerateReportRequest
   */
  end_time?: number
  /**
   *
   * @type {number}
   * @memberof DiagnoseGenerateReportRequest
   */
  start_time?: number
}
/**
 *
 * @export
 * @interface DiagnoseReport
 */
export interface DiagnoseReport {
  /**
   *
   * @type {string}
   * @memberof DiagnoseReport
   */
  compare_end_time?: string
  /**
   *
   * @type {string}
   * @memberof DiagnoseReport
   */
  compare_start_time?: string
  /**
   *
   * @type {string}
   * @memberof DiagnoseReport
   */
  content?: string
  /**
   *
   * @type {string}
   * @memberof DiagnoseReport
   */
  end_time?: string
  /**
   * 0~100
   * @type {number}
   * @memberof DiagnoseReport
   */
  progress?: number
  /**
   *
   * @type {string}
   * @memberof DiagnoseReport
   */
  start_time?: string
}
/**
 *
 * @export
 * @interface InfoInfoResponse
 */
export interface InfoInfoResponse {
  /**
   *
   * @type {string}
   * @memberof InfoInfoResponse
   */
  pd_end_point?: string
  /**
   *
   * @type {UtilsVersionInfo}
   * @memberof InfoInfoResponse
   */
  version?: UtilsVersionInfo
}
/**
 *
 * @export
 * @interface InfoWhoAmIResponse
 */
export interface InfoWhoAmIResponse {
  /**
   *
   * @type {string}
   * @memberof InfoWhoAmIResponse
   */
  username?: string
}
/**
 *
 * @export
 * @interface LogsearchCreateTaskGroupRequest
 */
export interface LogsearchCreateTaskGroupRequest {
  /**
   *
   * @type {LogsearchSearchLogRequest}
   * @memberof LogsearchCreateTaskGroupRequest
   */
  request: LogsearchSearchLogRequest
  /**
   *
   * @type {Array<UtilsRequestTargetNode>}
   * @memberof LogsearchCreateTaskGroupRequest
   */
  targets: Array<UtilsRequestTargetNode>
}
/**
 *
 * @export
 * @interface LogsearchPreviewModel
 */
export interface LogsearchPreviewModel {
  /**
   *
   * @type {number}
   * @memberof LogsearchPreviewModel
   */
  id?: number
  /**
   *
   * @type {number}
   * @memberof LogsearchPreviewModel
   */
  level?: number
  /**
   *
   * @type {string}
   * @memberof LogsearchPreviewModel
   */
  message?: string
  /**
   *
   * @type {number}
   * @memberof LogsearchPreviewModel
   */
  task_group_id?: number
  /**
   *
   * @type {number}
   * @memberof LogsearchPreviewModel
   */
  task_id?: number
  /**
   *
   * @type {number}
   * @memberof LogsearchPreviewModel
   */
  time?: number
}
/**
 *
 * @export
 * @interface LogsearchSearchLogRequest
 */
export interface LogsearchSearchLogRequest {
  /**
   *
   * @type {number}
   * @memberof LogsearchSearchLogRequest
   */
  end_time?: number
  /**
   *
   * @type {number}
   * @memberof LogsearchSearchLogRequest
   */
  min_level?: number
  /**
   * We use a string array to represent multiple CNF pattern sceniaor like: SELECT * FROM t WHERE c LIKE \'%s%\' and c REGEXP \'.*a.*\' because Golang and Rust don\'t support perl-like (?=re1)(?=re2)
   * @type {Array<string>}
   * @memberof LogsearchSearchLogRequest
   */
  patterns?: Array<string>
  /**
   *
   * @type {number}
   * @memberof LogsearchSearchLogRequest
   */
  start_time?: number
}
/**
 *
 * @export
 * @interface LogsearchTaskGroupModel
 */
export interface LogsearchTaskGroupModel {
  /**
   *
   * @type {number}
   * @memberof LogsearchTaskGroupModel
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof LogsearchTaskGroupModel
   */
  log_store_dir?: string
  /**
   *
   * @type {LogsearchSearchLogRequest}
   * @memberof LogsearchTaskGroupModel
   */
  search_request?: LogsearchSearchLogRequest
  /**
   *
   * @type {number}
   * @memberof LogsearchTaskGroupModel
   */
  state?: number
  /**
   *
   * @type {UtilsRequestTargetStatistics}
   * @memberof LogsearchTaskGroupModel
   */
  target_stats?: UtilsRequestTargetStatistics
}
/**
 *
 * @export
 * @interface LogsearchTaskGroupResponse
 */
export interface LogsearchTaskGroupResponse {
  /**
   *
   * @type {LogsearchTaskGroupModel}
   * @memberof LogsearchTaskGroupResponse
   */
  task_group?: LogsearchTaskGroupModel
  /**
   *
   * @type {Array<LogsearchTaskModel>}
   * @memberof LogsearchTaskGroupResponse
   */
  tasks?: Array<LogsearchTaskModel>
}
/**
 *
 * @export
 * @interface LogsearchTaskModel
 */
export interface LogsearchTaskModel {
  /**
   *
   * @type {string}
   * @memberof LogsearchTaskModel
   */
  error?: string
  /**
   *
   * @type {number}
   * @memberof LogsearchTaskModel
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof LogsearchTaskModel
   */
  log_store_path?: string
  /**
   *
   * @type {number}
   * @memberof LogsearchTaskModel
   */
  state?: number
  /**
   *
   * @type {UtilsRequestTargetNode}
   * @memberof LogsearchTaskModel
   */
  target?: UtilsRequestTargetNode
  /**
   *
   * @type {number}
   * @memberof LogsearchTaskModel
   */
  task_group_id?: number
}
/**
 *
 * @export
 * @interface MatrixMatrix
 */
export interface MatrixMatrix {
  /**
   *
   * @type {{ [key: string]: Array<Array<number>>; }}
   * @memberof MatrixMatrix
   */
  data: { [key: string]: Array<Array<number>> }
  /**
   *
   * @type {Array<DecoratorLabelKey>}
   * @memberof MatrixMatrix
   */
  keyAxis: Array<DecoratorLabelKey>
  /**
   *
   * @type {Array<number>}
   * @memberof MatrixMatrix
   */
  timeAxis: Array<number>
}
/**
 *
 * @export
 * @interface ProfilingGroupDetailResponse
 */
export interface ProfilingGroupDetailResponse {
  /**
   *
   * @type {number}
   * @memberof ProfilingGroupDetailResponse
   */
  server_time?: number
  /**
   *
   * @type {ProfilingTaskGroupModel}
   * @memberof ProfilingGroupDetailResponse
   */
  task_group_status?: ProfilingTaskGroupModel
  /**
   *
   * @type {Array<ProfilingTaskModel>}
   * @memberof ProfilingGroupDetailResponse
   */
  tasks_status?: Array<ProfilingTaskModel>
}
/**
 *
 * @export
 * @interface ProfilingStartRequest
 */
export interface ProfilingStartRequest {
  /**
   *
   * @type {number}
   * @memberof ProfilingStartRequest
   */
  duration_secs?: number
  /**
   *
   * @type {Array<UtilsRequestTargetNode>}
   * @memberof ProfilingStartRequest
   */
  targets?: Array<UtilsRequestTargetNode>
}
/**
 *
 * @export
 * @interface ProfilingTaskGroupModel
 */
export interface ProfilingTaskGroupModel {
  /**
   *
   * @type {number}
   * @memberof ProfilingTaskGroupModel
   */
  id?: number
  /**
   *
   * @type {number}
   * @memberof ProfilingTaskGroupModel
   */
  profile_duration_secs?: number
  /**
   *
   * @type {number}
   * @memberof ProfilingTaskGroupModel
   */
  started_at?: number
  /**
   *
   * @type {number}
   * @memberof ProfilingTaskGroupModel
   */
  state?: number
  /**
   *
   * @type {UtilsRequestTargetStatistics}
   * @memberof ProfilingTaskGroupModel
   */
  target_stats?: UtilsRequestTargetStatistics
}
/**
 *
 * @export
 * @interface ProfilingTaskModel
 */
export interface ProfilingTaskModel {
  /**
   *
   * @type {string}
   * @memberof ProfilingTaskModel
   */
  error?: string
  /**
   *
   * @type {string}
   * @memberof ProfilingTaskModel
   */
  file_path?: string
  /**
   *
   * @type {number}
   * @memberof ProfilingTaskModel
   */
  id?: number
  /**
   * The start running time, reset when retry. Used to estimate approximate profiling progress.
   * @type {number}
   * @memberof ProfilingTaskModel
   */
  started_at?: number
  /**
   *
   * @type {number}
   * @memberof ProfilingTaskModel
   */
  state?: number
  /**
   *
   * @type {UtilsRequestTargetNode}
   * @memberof ProfilingTaskModel
   */
  target?: UtilsRequestTargetNode
  /**
   *
   * @type {number}
   * @memberof ProfilingTaskModel
   */
  task_group_id?: number
}
/**
 *
 * @export
 * @interface StatementDetail
 */
export interface StatementDetail {
  /**
   *
   * @type {string}
   * @memberof StatementDetail
   */
  agg_table_names?: string
  /**
   *
   * @type {number}
   * @memberof StatementDetail
   */
  avg_affected_rows?: number
  /**
   *
   * @type {number}
   * @memberof StatementDetail
   */
  avg_total_keys?: number
  /**
   *
   * @type {string}
   * @memberof StatementDetail
   */
  digest?: string
  /**
   *
   * @type {string}
   * @memberof StatementDetail
   */
  digest_text?: string
  /**
   *
   * @type {number}
   * @memberof StatementDetail
   */
  exec_count?: number
  /**
   *
   * @type {string}
   * @memberof StatementDetail
   */
  last_seen?: string
  /**
   *
   * @type {Array<StatementPlan>}
   * @memberof StatementDetail
   */
  plans?: Array<StatementPlan>
  /**
   *
   * @type {string}
   * @memberof StatementDetail
   */
  query_sample_text?: string
  /**
   *
   * @type {string}
   * @memberof StatementDetail
   */
  schema_name?: string
  /**
   * Schemas is extracted from table_names column table_names example: \"d1.t1,d2.t2\", we extract the \"d1,d2\" as schemas
   * @type {string}
   * @memberof StatementDetail
   */
  schemas?: string
  /**
   *
   * @type {number}
   * @memberof StatementDetail
   */
  sum_latency?: number
}
/**
 *
 * @export
 * @interface StatementNode
 */
export interface StatementNode {
  /**
   *
   * @type {string}
   * @memberof StatementNode
   */
  address?: string
  /**
   *
   * @type {number}
   * @memberof StatementNode
   */
  avg_latency?: number
  /**
   *
   * @type {number}
   * @memberof StatementNode
   */
  avg_mem?: number
  /**
   *
   * @type {number}
   * @memberof StatementNode
   */
  exec_count?: number
  /**
   *
   * @type {number}
   * @memberof StatementNode
   */
  max_latency?: number
  /**
   *
   * @type {number}
   * @memberof StatementNode
   */
  sum_backoff_times?: number
  /**
   *
   * @type {number}
   * @memberof StatementNode
   */
  sum_latency?: number
}
/**
 *
 * @export
 * @interface StatementOverview
 */
export interface StatementOverview {
  /**
   *
   * @type {string}
   * @memberof StatementOverview
   */
  agg_table_names?: string
  /**
   *
   * @type {number}
   * @memberof StatementOverview
   */
  avg_affected_rows?: number
  /**
   *
   * @type {number}
   * @memberof StatementOverview
   */
  avg_latency?: number
  /**
   *
   * @type {number}
   * @memberof StatementOverview
   */
  avg_mem?: number
  /**
   *
   * @type {string}
   * @memberof StatementOverview
   */
  digest?: string
  /**
   *
   * @type {string}
   * @memberof StatementOverview
   */
  digest_text?: string
  /**
   *
   * @type {number}
   * @memberof StatementOverview
   */
  exec_count?: number
  /**
   *
   * @type {number}
   * @memberof StatementOverview
   */
  max_latency?: number
  /**
   *
   * @type {number}
   * @memberof StatementOverview
   */
  max_mem?: number
  /**
   *
   * @type {number}
   * @memberof StatementOverview
   */
  min_latency?: number
  /**
   *
   * @type {string}
   * @memberof StatementOverview
   */
  schema_name?: string
  /**
   * Schemas is extracted from table_names column table_names example: \"d1.t1,d2.t2\", we extract the \"d1,d2\" as schemas
   * @type {string}
   * @memberof StatementOverview
   */
  schemas?: string
  /**
   *
   * @type {number}
   * @memberof StatementOverview
   */
  sum_latency?: number
}
/**
 *
 * @export
 * @interface StatementPlan
 */
export interface StatementPlan {
  /**
   *
   * @type {string}
   * @memberof StatementPlan
   */
  content?: string
  /**
   *
   * @type {string}
   * @memberof StatementPlan
   */
  digest?: string
}
/**
 *
 * @export
 * @interface StatementTimeRange
 */
export interface StatementTimeRange {
  /**
   *
   * @type {number}
   * @memberof StatementTimeRange
   */
  begin_time?: number
  /**
   *
   * @type {number}
   * @memberof StatementTimeRange
   */
  end_time?: number
}
/**
 *
 * @export
 * @interface UserAuthenticateForm
 */
export interface UserAuthenticateForm {
  /**
   *
   * @type {boolean}
   * @memberof UserAuthenticateForm
   */
  is_tidb_auth: boolean
  /**
   *
   * @type {string}
   * @memberof UserAuthenticateForm
   */
  password?: string
  /**
   *
   * @type {string}
   * @memberof UserAuthenticateForm
   */
  username: string
}
/**
 *
 * @export
 * @interface UserTokenResponse
 */
export interface UserTokenResponse {
  /**
   *
   * @type {string}
   * @memberof UserTokenResponse
   */
  expire?: string
  /**
   *
   * @type {string}
   * @memberof UserTokenResponse
   */
  token?: string
}
/**
 *
 * @export
 * @interface UtilsAPIError
 */
export interface UtilsAPIError {
  /**
   *
   * @type {string}
   * @memberof UtilsAPIError
   */
  code?: string
  /**
   *
   * @type {boolean}
   * @memberof UtilsAPIError
   */
  error?: boolean
  /**
   *
   * @type {string}
   * @memberof UtilsAPIError
   */
  full_text?: string
  /**
   *
   * @type {string}
   * @memberof UtilsAPIError
   */
  message?: string
}
/**
 *
 * @export
 * @interface UtilsRequestTargetNode
 */
export interface UtilsRequestTargetNode {
  /**
   *
   * @type {string}
   * @memberof UtilsRequestTargetNode
   */
  display_name?: string
  /**
   *
   * @type {string}
   * @memberof UtilsRequestTargetNode
   */
  ip?: string
  /**
   *
   * @type {string}
   * @memberof UtilsRequestTargetNode
   */
  kind?: string
  /**
   *
   * @type {number}
   * @memberof UtilsRequestTargetNode
   */
  port?: number
}
/**
 *
 * @export
 * @interface UtilsRequestTargetStatistics
 */
export interface UtilsRequestTargetStatistics {
  /**
   *
   * @type {number}
   * @memberof UtilsRequestTargetStatistics
   */
  num_pd_nodes?: number
  /**
   *
   * @type {number}
   * @memberof UtilsRequestTargetStatistics
   */
  num_tidb_nodes?: number
  /**
   *
   * @type {number}
   * @memberof UtilsRequestTargetStatistics
   */
  num_tikv_nodes?: number
}
/**
 *
 * @export
 * @interface UtilsVersionInfo
 */
export interface UtilsVersionInfo {
  /**
   *
   * @type {string}
   * @memberof UtilsVersionInfo
   */
  build_git_branch?: string
  /**
   *
   * @type {string}
   * @memberof UtilsVersionInfo
   */
  build_git_hash?: string
  /**
   *
   * @type {string}
   * @memberof UtilsVersionInfo
   */
  build_time?: string
  /**
   *
   * @type {string}
   * @memberof UtilsVersionInfo
   */
  release_version?: string
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Cancel all profling tasks with a given group ID
     * @summary Cancel all tasks with a given group ID
     * @param {string} groupId group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelProfilingGroup(groupId: string, options: any = {}): RequestArgs {
      // verify required parameter 'groupId' is not null or undefined
      if (groupId === null || groupId === undefined) {
        throw new RequiredError(
          'groupId',
          'Required parameter groupId was null or undefined when calling cancelProfilingGroup.'
        )
      }
      const localVarPath = `/profiling/group/cancel/{groupId}`.replace(
        `{${'groupId'}}`,
        encodeURIComponent(String(groupId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete all finished profiling tasks with a given group ID
     * @summary Delete all tasks with a given group ID
     * @param {string} groupId group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProfilingGroup(groupId: string, options: any = {}): RequestArgs {
      // verify required parameter 'groupId' is not null or undefined
      if (groupId === null || groupId === undefined) {
        throw new RequiredError(
          'groupId',
          'Required parameter groupId was null or undefined when calling deleteProfilingGroup.'
        )
      }
      const localVarPath = `/profiling/group/delete/{groupId}`.replace(
        `{${'groupId'}}`,
        encodeURIComponent(String(groupId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get sql diagnosis report data
     * @summary SQL diagnosis report data
     * @param {string} id report id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diagnoseReportsIdDataJsGet(id: string, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling diagnoseReportsIdDataJsGet.'
        )
      }
      const localVarPath = `/diagnose/reports/{id}/data.js`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get sql diagnosis report HTML
     * @summary SQL diagnosis report
     * @param {string} id report id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diagnoseReportsIdDetailGet(id: string, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling diagnoseReportsIdDetailGet.'
        )
      }
      const localVarPath = `/diagnose/reports/{id}/detail`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get diagnosis report status
     * @summary Diagnosis report status
     * @param {string} id report id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diagnoseReportsIdStatusGet(id: string, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling diagnoseReportsIdStatusGet.'
        )
      }
      const localVarPath = `/diagnose/reports/{id}/status`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Generate sql diagnosis report
     * @summary SQL diagnosis report
     * @param {DiagnoseGenerateReportRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diagnoseReportsPost(
      request: DiagnoseGenerateReportRequest,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError(
          'request',
          'Required parameter request was null or undefined when calling diagnoseReportsPost.'
        )
      }
      const localVarPath = `/diagnose/reports`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }
      const needsSerialization =
        typeof request !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(request !== undefined ? request : {})
        : request || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Download all finished profiling results of a task group
     * @summary Download all results of a task group
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadProfilingGroup(token: string, options: any = {}): RequestArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          'token',
          'Required parameter token was null or undefined when calling downloadProfilingGroup.'
        )
      }
      const localVarPath = `/profiling/group/download`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      if (token !== undefined) {
        localVarQueryParameter['token'] = token
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Download the finished profiling result of a task
     * @summary Download the result of a task
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadProfilingSingle(token: string, options: any = {}): RequestArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          'token',
          'Required parameter token was null or undefined when calling downloadProfilingSingle.'
        )
      }
      const localVarPath = `/profiling/single/download`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      if (token !== undefined) {
        localVarQueryParameter['token'] = token
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Hello world!
     * @summary Greet
     * @param {string} name Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fooBarNameGet(name: string, options: any = {}): RequestArgs {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling fooBarNameGet.'
        )
      }
      const localVarPath = `/foo/bar/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get information about the dashboard service.
     * @summary Dashboard info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfo(options: any = {}): RequestArgs {
      const localVarPath = `/info/info`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List all profiling tasks with a given group ID
     * @summary List all tasks with a given group ID
     * @param {string} groupId group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfilingGroupDetail(groupId: string, options: any = {}): RequestArgs {
      // verify required parameter 'groupId' is not null or undefined
      if (groupId === null || groupId === undefined) {
        throw new RequiredError(
          'groupId',
          'Required parameter groupId was null or undefined when calling getProfilingGroupDetail.'
        )
      }
      const localVarPath = `/profiling/group/detail/{groupId}`.replace(
        `{${'groupId'}}`,
        encodeURIComponent(String(groupId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get download token with a given group ID
     * @summary Get download token for group download
     * @param {string} [id] group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfilingGroupDownloadToken(
      id?: string,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/profiling/group/download/acquire_token`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List all profiling groups
     * @summary List all profiling groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfilingGroups(options: any = {}): RequestArgs {
      const localVarPath = `/profiling/group/list`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get download token with a given task ID
     * @summary Get download token for single download
     * @param {string} [id] task ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfilingSingleDownloadToken(
      id?: string,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/profiling/single/download/acquire_token`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all databases.
     * @summary Example: Get all databases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infoDatabasesGet(options: any = {}): RequestArgs {
      const localVarPath = `/info/databases`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get current login session
     * @summary Current login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infoWhoamiGet(options: any = {}): RequestArgs {
      const localVarPath = `/info/whoami`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Heatmaps in a given range to visualize TiKV usage
     * @summary Key Visual Heatmaps
     * @param {string} [startkey] The start of the key range
     * @param {string} [endkey] The end of the key range
     * @param {number} [starttime] The start of the time range (Unix)
     * @param {number} [endtime] The end of the time range (Unix)
     * @param {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'} [type] Main types of data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keyvisualHeatmapsGet(
      startkey?: string,
      endkey?: string,
      starttime?: number,
      endtime?: number,
      type?:
        | 'written_bytes'
        | 'read_bytes'
        | 'written_keys'
        | 'read_keys'
        | 'integration',
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/keyvisual/heatmaps`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      if (startkey !== undefined) {
        localVarQueryParameter['startkey'] = startkey
      }

      if (endkey !== undefined) {
        localVarQueryParameter['endkey'] = endkey
      }

      if (starttime !== undefined) {
        localVarQueryParameter['starttime'] = starttime
      }

      if (endtime !== undefined) {
        localVarQueryParameter['endtime'] = endtime
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * get download token with multiple task IDs
     * @summary Get download token
     * @param {Array<string>} [id] task id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsDownloadAcquireTokenGet(
      id?: Array<string>,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/logs/download/acquire_token`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      if (id) {
        localVarQueryParameter['id'] = id.join(COLLECTION_FORMATS.csv)
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * download logs by multiple task IDs
     * @summary Download
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsDownloadGet(token: string, options: any = {}): RequestArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          'token',
          'Required parameter token was null or undefined when calling logsDownloadGet.'
        )
      }
      const localVarPath = `/logs/download`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (token !== undefined) {
        localVarQueryParameter['token'] = token
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create and run task group
     * @summary Create and run task group
     * @param {LogsearchCreateTaskGroupRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupPut(
      request: LogsearchCreateTaskGroupRequest,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'request' is not null or undefined
      if (request === null || request === undefined) {
        throw new RequiredError(
          'request',
          'Required parameter request was null or undefined when calling logsTaskgroupPut.'
        )
      }
      const localVarPath = `/logs/taskgroup`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }
      const needsSerialization =
        typeof request !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(request !== undefined ? request : {})
        : request || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * list all log search taskgroups
     * @summary List all task groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsGet(options: any = {}): RequestArgs {
      const localVarPath = `/logs/taskgroups`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * cancel all running tasks in a task group
     * @summary Cancel running tasks
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsIdCancelPost(id: string, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling logsTaskgroupsIdCancelPost.'
        )
      }
      const localVarPath = `/logs/taskgroups/{id}/cancel`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * delete a task group by providing task group ID
     * @summary Delete task group
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsIdDelete(id: string, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling logsTaskgroupsIdDelete.'
        )
      }
      const localVarPath = `/logs/taskgroups/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * list all log search tasks in a task group by providing task group ID
     * @summary List tasks in a task group
     * @param {string} id Task Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsIdGet(id: string, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling logsTaskgroupsIdGet.'
        )
      }
      const localVarPath = `/logs/taskgroups/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * preview fetched logs in a task group by providing task group ID
     * @summary Preview logs in a task group
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsIdPreviewGet(id: string, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling logsTaskgroupsIdPreviewGet.'
        )
      }
      const localVarPath = `/logs/taskgroups/{id}/preview`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * retry tasks that has been failed in a task group
     * @summary Retry failed tasks
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsIdRetryPost(id: string, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling logsTaskgroupsIdRetryPost.'
        )
      }
      const localVarPath = `/logs/taskgroups/{id}/retry`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Start a profiling task group
     * @summary Start profiling
     * @param {ProfilingStartRequest} pr profiling request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startProfiling(pr: ProfilingStartRequest, options: any = {}): RequestArgs {
      // verify required parameter 'pr' is not null or undefined
      if (pr === null || pr === undefined) {
        throw new RequiredError(
          'pr',
          'Required parameter pr was null or undefined when calling startProfiling.'
        )
      }
      const localVarPath = `/profiling/group/start`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }
      const needsSerialization =
        typeof pr !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pr !== undefined ? pr : {})
        : pr || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get statement detail
     * @summary Statement detail
     * @param {string} schema Statement schema
     * @param {string} begin_time Statement begin time
     * @param {string} end_time Statement end time
     * @param {string} digest Statement digest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statementsDetailGet(
      schema: string,
      begin_time: string,
      end_time: string,
      digest: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'schema' is not null or undefined
      if (schema === null || schema === undefined) {
        throw new RequiredError(
          'schema',
          'Required parameter schema was null or undefined when calling statementsDetailGet.'
        )
      }
      // verify required parameter 'begin_time' is not null or undefined
      if (begin_time === null || begin_time === undefined) {
        throw new RequiredError(
          'begin_time',
          'Required parameter begin_time was null or undefined when calling statementsDetailGet.'
        )
      }
      // verify required parameter 'end_time' is not null or undefined
      if (end_time === null || end_time === undefined) {
        throw new RequiredError(
          'end_time',
          'Required parameter end_time was null or undefined when calling statementsDetailGet.'
        )
      }
      // verify required parameter 'digest' is not null or undefined
      if (digest === null || digest === undefined) {
        throw new RequiredError(
          'digest',
          'Required parameter digest was null or undefined when calling statementsDetailGet.'
        )
      }
      const localVarPath = `/statements/detail`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      if (schema !== undefined) {
        localVarQueryParameter['schema'] = schema
      }

      if (begin_time !== undefined) {
        localVarQueryParameter['begin_time'] = begin_time
      }

      if (end_time !== undefined) {
        localVarQueryParameter['end_time'] = end_time
      }

      if (digest !== undefined) {
        localVarQueryParameter['digest'] = digest
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get statement in each node
     * @summary Statement nodes
     * @param {string} schema Statement schema
     * @param {string} begin_time Statement begin time
     * @param {string} end_time Statement end time
     * @param {string} digest Statement digest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statementsNodesGet(
      schema: string,
      begin_time: string,
      end_time: string,
      digest: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'schema' is not null or undefined
      if (schema === null || schema === undefined) {
        throw new RequiredError(
          'schema',
          'Required parameter schema was null or undefined when calling statementsNodesGet.'
        )
      }
      // verify required parameter 'begin_time' is not null or undefined
      if (begin_time === null || begin_time === undefined) {
        throw new RequiredError(
          'begin_time',
          'Required parameter begin_time was null or undefined when calling statementsNodesGet.'
        )
      }
      // verify required parameter 'end_time' is not null or undefined
      if (end_time === null || end_time === undefined) {
        throw new RequiredError(
          'end_time',
          'Required parameter end_time was null or undefined when calling statementsNodesGet.'
        )
      }
      // verify required parameter 'digest' is not null or undefined
      if (digest === null || digest === undefined) {
        throw new RequiredError(
          'digest',
          'Required parameter digest was null or undefined when calling statementsNodesGet.'
        )
      }
      const localVarPath = `/statements/nodes`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      if (schema !== undefined) {
        localVarQueryParameter['schema'] = schema
      }

      if (begin_time !== undefined) {
        localVarQueryParameter['begin_time'] = begin_time
      }

      if (end_time !== undefined) {
        localVarQueryParameter['end_time'] = end_time
      }

      if (digest !== undefined) {
        localVarQueryParameter['digest'] = digest
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get statements overview
     * @summary Statements overview
     * @param {string} begin_time Statement begin time
     * @param {string} end_time Statement end time
     * @param {string} [schemas] Target schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statementsOverviewsGet(
      begin_time: string,
      end_time: string,
      schemas?: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'begin_time' is not null or undefined
      if (begin_time === null || begin_time === undefined) {
        throw new RequiredError(
          'begin_time',
          'Required parameter begin_time was null or undefined when calling statementsOverviewsGet.'
        )
      }
      // verify required parameter 'end_time' is not null or undefined
      if (end_time === null || end_time === undefined) {
        throw new RequiredError(
          'end_time',
          'Required parameter end_time was null or undefined when calling statementsOverviewsGet.'
        )
      }
      const localVarPath = `/statements/overviews`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      if (schemas !== undefined) {
        localVarQueryParameter['schemas'] = schemas
      }

      if (begin_time !== undefined) {
        localVarQueryParameter['begin_time'] = begin_time
      }

      if (end_time !== undefined) {
        localVarQueryParameter['end_time'] = end_time
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all databases of TiDB
     * @summary TiDB databases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statementsSchemasGet(options: any = {}): RequestArgs {
      const localVarPath = `/statements/schemas`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all time ranges of the statements
     * @summary Statement time ranges
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statementsTimeRangesGet(options: any = {}): RequestArgs {
      const localVarPath = `/statements/time_ranges`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get alert number of the alert manager.
     * @summary Get the count of alert
     * @param {string} address ip:port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    topologyAlertmanagerAddressCountGet(
      address: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'address' is not null or undefined
      if (address === null || address === undefined) {
        throw new RequiredError(
          'address',
          'Required parameter address was null or undefined when calling topologyAlertmanagerAddressCountGet.'
        )
      }
      const localVarPath = `/topology/alertmanager/{address}/count`.replace(
        `{${'address'}}`,
        encodeURIComponent(String(address))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get information about the dashboard topology.
     * @summary Get all Dashboard topology and liveness.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    topologyAllGet(options: any = {}): RequestArgs {
      const localVarPath = `/topology/all`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete etcd\'s TiDB key with ip:port.
     * @summary Delete etcd\'s tidb key.
     * @param {string} address ip:port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    topologyTidbAddressDelete(address: string, options: any = {}): RequestArgs {
      // verify required parameter 'address' is not null or undefined
      if (address === null || address === undefined) {
        throw new RequiredError(
          'address',
          'Required parameter address was null or undefined when calling topologyTidbAddressDelete.'
        )
      }
      const localVarPath = `/topology/tidb/{address}`.replace(
        `{${'address'}}`,
        encodeURIComponent(String(address))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JwtAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Log into dashboard.
     * @summary Log in
     * @param {UserAuthenticateForm} message Credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userLoginPost(
      message: UserAuthenticateForm,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'message' is not null or undefined
      if (message === null || message === undefined) {
        throw new RequiredError(
          'message',
          'Required parameter message was null or undefined when calling userLoginPost.'
        )
      }
      const localVarPath = `/user/login`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      }
      const needsSerialization =
        typeof message !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(message !== undefined ? message : {})
        : message || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Cancel all profling tasks with a given group ID
     * @summary Cancel all tasks with a given group ID
     * @param {string} groupId group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelProfilingGroup(
      groupId: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).cancelProfilingGroup(groupId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete all finished profiling tasks with a given group ID
     * @summary Delete all tasks with a given group ID
     * @param {string} groupId group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProfilingGroup(
      groupId: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).deleteProfilingGroup(groupId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Get sql diagnosis report data
     * @summary SQL diagnosis report data
     * @param {string} id report id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diagnoseReportsIdDataJsGet(
      id: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).diagnoseReportsIdDataJsGet(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Get sql diagnosis report HTML
     * @summary SQL diagnosis report
     * @param {string} id report id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diagnoseReportsIdDetailGet(
      id: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).diagnoseReportsIdDetailGet(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Get diagnosis report status
     * @summary Diagnosis report status
     * @param {string} id report id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diagnoseReportsIdStatusGet(
      id: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<DiagnoseReport> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).diagnoseReportsIdStatusGet(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Generate sql diagnosis report
     * @summary SQL diagnosis report
     * @param {DiagnoseGenerateReportRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diagnoseReportsPost(
      request: DiagnoseGenerateReportRequest,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).diagnoseReportsPost(request, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Download all finished profiling results of a task group
     * @summary Download all results of a task group
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadProfilingGroup(
      token: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).downloadProfilingGroup(token, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Download the finished profiling result of a task
     * @summary Download the result of a task
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadProfilingSingle(
      token: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).downloadProfilingSingle(token, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Hello world!
     * @summary Greet
     * @param {string} name Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fooBarNameGet(
      name: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).fooBarNameGet(name, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Get information about the dashboard service.
     * @summary Dashboard info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfo(
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<InfoInfoResponse> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).getInfo(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * List all profiling tasks with a given group ID
     * @summary List all tasks with a given group ID
     * @param {string} groupId group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfilingGroupDetail(
      groupId: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<ProfilingGroupDetailResponse> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).getProfilingGroupDetail(groupId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Get download token with a given group ID
     * @summary Get download token for group download
     * @param {string} [id] group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfilingGroupDownloadToken(
      id?: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).getProfilingGroupDownloadToken(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * List all profiling groups
     * @summary List all profiling groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfilingGroups(
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<Array<ProfilingTaskGroupModel>> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).getProfilingGroups(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Get download token with a given task ID
     * @summary Get download token for single download
     * @param {string} [id] task ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfilingSingleDownloadToken(
      id?: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).getProfilingSingleDownloadToken(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Get all databases.
     * @summary Example: Get all databases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infoDatabasesGet(
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<Array<string>> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).infoDatabasesGet(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Get current login session
     * @summary Current login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infoWhoamiGet(
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<InfoWhoAmIResponse> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).infoWhoamiGet(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Heatmaps in a given range to visualize TiKV usage
     * @summary Key Visual Heatmaps
     * @param {string} [startkey] The start of the key range
     * @param {string} [endkey] The end of the key range
     * @param {number} [starttime] The start of the time range (Unix)
     * @param {number} [endtime] The end of the time range (Unix)
     * @param {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'} [type] Main types of data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keyvisualHeatmapsGet(
      startkey?: string,
      endkey?: string,
      starttime?: number,
      endtime?: number,
      type?:
        | 'written_bytes'
        | 'read_bytes'
        | 'written_keys'
        | 'read_keys'
        | 'integration',
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<MatrixMatrix> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).keyvisualHeatmapsGet(
        startkey,
        endkey,
        starttime,
        endtime,
        type,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * get download token with multiple task IDs
     * @summary Get download token
     * @param {Array<string>} [id] task id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsDownloadAcquireTokenGet(
      id?: Array<string>,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).logsDownloadAcquireTokenGet(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * download logs by multiple task IDs
     * @summary Download
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsDownloadGet(
      token: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).logsDownloadGet(token, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Create and run task group
     * @summary Create and run task group
     * @param {LogsearchCreateTaskGroupRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupPut(
      request: LogsearchCreateTaskGroupRequest,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<LogsearchTaskGroupResponse> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).logsTaskgroupPut(request, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * list all log search taskgroups
     * @summary List all task groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsGet(
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<Array<LogsearchTaskGroupModel>> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).logsTaskgroupsGet(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * cancel all running tasks in a task group
     * @summary Cancel running tasks
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsIdCancelPost(
      id: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).logsTaskgroupsIdCancelPost(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * delete a task group by providing task group ID
     * @summary Delete task group
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsIdDelete(
      id: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).logsTaskgroupsIdDelete(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * list all log search tasks in a task group by providing task group ID
     * @summary List tasks in a task group
     * @param {string} id Task Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsIdGet(
      id: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<LogsearchTaskGroupResponse> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).logsTaskgroupsIdGet(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * preview fetched logs in a task group by providing task group ID
     * @summary Preview logs in a task group
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsIdPreviewGet(
      id: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<Array<LogsearchPreviewModel>> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).logsTaskgroupsIdPreviewGet(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * retry tasks that has been failed in a task group
     * @summary Retry failed tasks
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsIdRetryPost(
      id: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).logsTaskgroupsIdRetryPost(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Start a profiling task group
     * @summary Start profiling
     * @param {ProfilingStartRequest} pr profiling request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startProfiling(
      pr: ProfilingStartRequest,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<ProfilingTaskGroupModel> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).startProfiling(pr, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Get statement detail
     * @summary Statement detail
     * @param {string} schema Statement schema
     * @param {string} begin_time Statement begin time
     * @param {string} end_time Statement end time
     * @param {string} digest Statement digest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statementsDetailGet(
      schema: string,
      begin_time: string,
      end_time: string,
      digest: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<StatementDetail> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).statementsDetailGet(schema, begin_time, end_time, digest, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Get statement in each node
     * @summary Statement nodes
     * @param {string} schema Statement schema
     * @param {string} begin_time Statement begin time
     * @param {string} end_time Statement end time
     * @param {string} digest Statement digest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statementsNodesGet(
      schema: string,
      begin_time: string,
      end_time: string,
      digest: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<Array<StatementNode>> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).statementsNodesGet(schema, begin_time, end_time, digest, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Get statements overview
     * @summary Statements overview
     * @param {string} begin_time Statement begin time
     * @param {string} end_time Statement end time
     * @param {string} [schemas] Target schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statementsOverviewsGet(
      begin_time: string,
      end_time: string,
      schemas?: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<Array<StatementOverview>> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).statementsOverviewsGet(begin_time, end_time, schemas, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Get all databases of TiDB
     * @summary TiDB databases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statementsSchemasGet(
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<Array<string>> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).statementsSchemasGet(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Get all time ranges of the statements
     * @summary Statement time ranges
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statementsTimeRangesGet(
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<Array<StatementTimeRange>> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).statementsTimeRangesGet(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Get alert number of the alert manager.
     * @summary Get the count of alert
     * @param {string} address ip:port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    topologyAlertmanagerAddressCountGet(
      address: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).topologyAlertmanagerAddressCountGet(address, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Get information about the dashboard topology.
     * @summary Get all Dashboard topology and liveness.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    topologyAllGet(
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<ClusterinfoClusterInfo> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).topologyAllGet(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete etcd\'s TiDB key with ip:port.
     * @summary Delete etcd\'s tidb key.
     * @param {string} address ip:port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    topologyTidbAddressDelete(
      address: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).topologyTidbAddressDelete(address, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Log into dashboard.
     * @summary Log in
     * @param {UserAuthenticateForm} message Credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userLoginPost(
      message: UserAuthenticateForm,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<UserTokenResponse> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(
        configuration
      ).userLoginPost(message, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Cancel all profling tasks with a given group ID
     * @summary Cancel all tasks with a given group ID
     * @param {string} groupId group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelProfilingGroup(groupId: string, options?: any) {
      return DefaultApiFp(configuration).cancelProfilingGroup(groupId, options)(
        axios,
        basePath
      )
    },
    /**
     * Delete all finished profiling tasks with a given group ID
     * @summary Delete all tasks with a given group ID
     * @param {string} groupId group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProfilingGroup(groupId: string, options?: any) {
      return DefaultApiFp(configuration).deleteProfilingGroup(groupId, options)(
        axios,
        basePath
      )
    },
    /**
     * Get sql diagnosis report data
     * @summary SQL diagnosis report data
     * @param {string} id report id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diagnoseReportsIdDataJsGet(id: string, options?: any) {
      return DefaultApiFp(configuration).diagnoseReportsIdDataJsGet(
        id,
        options
      )(axios, basePath)
    },
    /**
     * Get sql diagnosis report HTML
     * @summary SQL diagnosis report
     * @param {string} id report id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diagnoseReportsIdDetailGet(id: string, options?: any) {
      return DefaultApiFp(configuration).diagnoseReportsIdDetailGet(
        id,
        options
      )(axios, basePath)
    },
    /**
     * Get diagnosis report status
     * @summary Diagnosis report status
     * @param {string} id report id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diagnoseReportsIdStatusGet(id: string, options?: any) {
      return DefaultApiFp(configuration).diagnoseReportsIdStatusGet(
        id,
        options
      )(axios, basePath)
    },
    /**
     * Generate sql diagnosis report
     * @summary SQL diagnosis report
     * @param {DiagnoseGenerateReportRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diagnoseReportsPost(request: DiagnoseGenerateReportRequest, options?: any) {
      return DefaultApiFp(configuration).diagnoseReportsPost(request, options)(
        axios,
        basePath
      )
    },
    /**
     * Download all finished profiling results of a task group
     * @summary Download all results of a task group
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadProfilingGroup(token: string, options?: any) {
      return DefaultApiFp(configuration).downloadProfilingGroup(token, options)(
        axios,
        basePath
      )
    },
    /**
     * Download the finished profiling result of a task
     * @summary Download the result of a task
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadProfilingSingle(token: string, options?: any) {
      return DefaultApiFp(configuration).downloadProfilingSingle(
        token,
        options
      )(axios, basePath)
    },
    /**
     * Hello world!
     * @summary Greet
     * @param {string} name Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fooBarNameGet(name: string, options?: any) {
      return DefaultApiFp(configuration).fooBarNameGet(name, options)(
        axios,
        basePath
      )
    },
    /**
     * Get information about the dashboard service.
     * @summary Dashboard info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfo(options?: any) {
      return DefaultApiFp(configuration).getInfo(options)(axios, basePath)
    },
    /**
     * List all profiling tasks with a given group ID
     * @summary List all tasks with a given group ID
     * @param {string} groupId group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfilingGroupDetail(groupId: string, options?: any) {
      return DefaultApiFp(configuration).getProfilingGroupDetail(
        groupId,
        options
      )(axios, basePath)
    },
    /**
     * Get download token with a given group ID
     * @summary Get download token for group download
     * @param {string} [id] group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfilingGroupDownloadToken(id?: string, options?: any) {
      return DefaultApiFp(configuration).getProfilingGroupDownloadToken(
        id,
        options
      )(axios, basePath)
    },
    /**
     * List all profiling groups
     * @summary List all profiling groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfilingGroups(options?: any) {
      return DefaultApiFp(configuration).getProfilingGroups(options)(
        axios,
        basePath
      )
    },
    /**
     * Get download token with a given task ID
     * @summary Get download token for single download
     * @param {string} [id] task ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfilingSingleDownloadToken(id?: string, options?: any) {
      return DefaultApiFp(configuration).getProfilingSingleDownloadToken(
        id,
        options
      )(axios, basePath)
    },
    /**
     * Get all databases.
     * @summary Example: Get all databases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infoDatabasesGet(options?: any) {
      return DefaultApiFp(configuration).infoDatabasesGet(options)(
        axios,
        basePath
      )
    },
    /**
     * Get current login session
     * @summary Current login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infoWhoamiGet(options?: any) {
      return DefaultApiFp(configuration).infoWhoamiGet(options)(axios, basePath)
    },
    /**
     * Heatmaps in a given range to visualize TiKV usage
     * @summary Key Visual Heatmaps
     * @param {string} [startkey] The start of the key range
     * @param {string} [endkey] The end of the key range
     * @param {number} [starttime] The start of the time range (Unix)
     * @param {number} [endtime] The end of the time range (Unix)
     * @param {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'} [type] Main types of data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keyvisualHeatmapsGet(
      startkey?: string,
      endkey?: string,
      starttime?: number,
      endtime?: number,
      type?:
        | 'written_bytes'
        | 'read_bytes'
        | 'written_keys'
        | 'read_keys'
        | 'integration',
      options?: any
    ) {
      return DefaultApiFp(configuration).keyvisualHeatmapsGet(
        startkey,
        endkey,
        starttime,
        endtime,
        type,
        options
      )(axios, basePath)
    },
    /**
     * get download token with multiple task IDs
     * @summary Get download token
     * @param {Array<string>} [id] task id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsDownloadAcquireTokenGet(id?: Array<string>, options?: any) {
      return DefaultApiFp(configuration).logsDownloadAcquireTokenGet(
        id,
        options
      )(axios, basePath)
    },
    /**
     * download logs by multiple task IDs
     * @summary Download
     * @param {string} token download token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsDownloadGet(token: string, options?: any) {
      return DefaultApiFp(configuration).logsDownloadGet(token, options)(
        axios,
        basePath
      )
    },
    /**
     * Create and run task group
     * @summary Create and run task group
     * @param {LogsearchCreateTaskGroupRequest} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupPut(request: LogsearchCreateTaskGroupRequest, options?: any) {
      return DefaultApiFp(configuration).logsTaskgroupPut(request, options)(
        axios,
        basePath
      )
    },
    /**
     * list all log search taskgroups
     * @summary List all task groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsGet(options?: any) {
      return DefaultApiFp(configuration).logsTaskgroupsGet(options)(
        axios,
        basePath
      )
    },
    /**
     * cancel all running tasks in a task group
     * @summary Cancel running tasks
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsIdCancelPost(id: string, options?: any) {
      return DefaultApiFp(configuration).logsTaskgroupsIdCancelPost(
        id,
        options
      )(axios, basePath)
    },
    /**
     * delete a task group by providing task group ID
     * @summary Delete task group
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsIdDelete(id: string, options?: any) {
      return DefaultApiFp(configuration).logsTaskgroupsIdDelete(id, options)(
        axios,
        basePath
      )
    },
    /**
     * list all log search tasks in a task group by providing task group ID
     * @summary List tasks in a task group
     * @param {string} id Task Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsIdGet(id: string, options?: any) {
      return DefaultApiFp(configuration).logsTaskgroupsIdGet(id, options)(
        axios,
        basePath
      )
    },
    /**
     * preview fetched logs in a task group by providing task group ID
     * @summary Preview logs in a task group
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsIdPreviewGet(id: string, options?: any) {
      return DefaultApiFp(configuration).logsTaskgroupsIdPreviewGet(
        id,
        options
      )(axios, basePath)
    },
    /**
     * retry tasks that has been failed in a task group
     * @summary Retry failed tasks
     * @param {string} id task group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsTaskgroupsIdRetryPost(id: string, options?: any) {
      return DefaultApiFp(configuration).logsTaskgroupsIdRetryPost(id, options)(
        axios,
        basePath
      )
    },
    /**
     * Start a profiling task group
     * @summary Start profiling
     * @param {ProfilingStartRequest} pr profiling request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startProfiling(pr: ProfilingStartRequest, options?: any) {
      return DefaultApiFp(configuration).startProfiling(pr, options)(
        axios,
        basePath
      )
    },
    /**
     * Get statement detail
     * @summary Statement detail
     * @param {string} schema Statement schema
     * @param {string} begin_time Statement begin time
     * @param {string} end_time Statement end time
     * @param {string} digest Statement digest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statementsDetailGet(
      schema: string,
      begin_time: string,
      end_time: string,
      digest: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).statementsDetailGet(
        schema,
        begin_time,
        end_time,
        digest,
        options
      )(axios, basePath)
    },
    /**
     * Get statement in each node
     * @summary Statement nodes
     * @param {string} schema Statement schema
     * @param {string} begin_time Statement begin time
     * @param {string} end_time Statement end time
     * @param {string} digest Statement digest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statementsNodesGet(
      schema: string,
      begin_time: string,
      end_time: string,
      digest: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).statementsNodesGet(
        schema,
        begin_time,
        end_time,
        digest,
        options
      )(axios, basePath)
    },
    /**
     * Get statements overview
     * @summary Statements overview
     * @param {string} begin_time Statement begin time
     * @param {string} end_time Statement end time
     * @param {string} [schemas] Target schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statementsOverviewsGet(
      begin_time: string,
      end_time: string,
      schemas?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).statementsOverviewsGet(
        begin_time,
        end_time,
        schemas,
        options
      )(axios, basePath)
    },
    /**
     * Get all databases of TiDB
     * @summary TiDB databases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statementsSchemasGet(options?: any) {
      return DefaultApiFp(configuration).statementsSchemasGet(options)(
        axios,
        basePath
      )
    },
    /**
     * Get all time ranges of the statements
     * @summary Statement time ranges
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statementsTimeRangesGet(options?: any) {
      return DefaultApiFp(configuration).statementsTimeRangesGet(options)(
        axios,
        basePath
      )
    },
    /**
     * Get alert number of the alert manager.
     * @summary Get the count of alert
     * @param {string} address ip:port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    topologyAlertmanagerAddressCountGet(address: string, options?: any) {
      return DefaultApiFp(configuration).topologyAlertmanagerAddressCountGet(
        address,
        options
      )(axios, basePath)
    },
    /**
     * Get information about the dashboard topology.
     * @summary Get all Dashboard topology and liveness.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    topologyAllGet(options?: any) {
      return DefaultApiFp(configuration).topologyAllGet(options)(
        axios,
        basePath
      )
    },
    /**
     * Delete etcd\'s TiDB key with ip:port.
     * @summary Delete etcd\'s tidb key.
     * @param {string} address ip:port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    topologyTidbAddressDelete(address: string, options?: any) {
      return DefaultApiFp(configuration).topologyTidbAddressDelete(
        address,
        options
      )(axios, basePath)
    },
    /**
     * Log into dashboard.
     * @summary Log in
     * @param {UserAuthenticateForm} message Credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userLoginPost(message: UserAuthenticateForm, options?: any) {
      return DefaultApiFp(configuration).userLoginPost(message, options)(
        axios,
        basePath
      )
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Cancel all profling tasks with a given group ID
   * @summary Cancel all tasks with a given group ID
   * @param {string} groupId group ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public cancelProfilingGroup(groupId: string, options?: any) {
    return DefaultApiFp(this.configuration).cancelProfilingGroup(
      groupId,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Delete all finished profiling tasks with a given group ID
   * @summary Delete all tasks with a given group ID
   * @param {string} groupId group ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteProfilingGroup(groupId: string, options?: any) {
    return DefaultApiFp(this.configuration).deleteProfilingGroup(
      groupId,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Get sql diagnosis report data
   * @summary SQL diagnosis report data
   * @param {string} id report id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public diagnoseReportsIdDataJsGet(id: string, options?: any) {
    return DefaultApiFp(this.configuration).diagnoseReportsIdDataJsGet(
      id,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Get sql diagnosis report HTML
   * @summary SQL diagnosis report
   * @param {string} id report id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public diagnoseReportsIdDetailGet(id: string, options?: any) {
    return DefaultApiFp(this.configuration).diagnoseReportsIdDetailGet(
      id,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Get diagnosis report status
   * @summary Diagnosis report status
   * @param {string} id report id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public diagnoseReportsIdStatusGet(id: string, options?: any) {
    return DefaultApiFp(this.configuration).diagnoseReportsIdStatusGet(
      id,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Generate sql diagnosis report
   * @summary SQL diagnosis report
   * @param {DiagnoseGenerateReportRequest} request Request body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public diagnoseReportsPost(
    request: DiagnoseGenerateReportRequest,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).diagnoseReportsPost(
      request,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Download all finished profiling results of a task group
   * @summary Download all results of a task group
   * @param {string} token download token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public downloadProfilingGroup(token: string, options?: any) {
    return DefaultApiFp(this.configuration).downloadProfilingGroup(
      token,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Download the finished profiling result of a task
   * @summary Download the result of a task
   * @param {string} token download token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public downloadProfilingSingle(token: string, options?: any) {
    return DefaultApiFp(this.configuration).downloadProfilingSingle(
      token,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Hello world!
   * @summary Greet
   * @param {string} name Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public fooBarNameGet(name: string, options?: any) {
    return DefaultApiFp(this.configuration).fooBarNameGet(name, options)(
      this.axios,
      this.basePath
    )
  }

  /**
   * Get information about the dashboard service.
   * @summary Dashboard info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getInfo(options?: any) {
    return DefaultApiFp(this.configuration).getInfo(options)(
      this.axios,
      this.basePath
    )
  }

  /**
   * List all profiling tasks with a given group ID
   * @summary List all tasks with a given group ID
   * @param {string} groupId group ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getProfilingGroupDetail(groupId: string, options?: any) {
    return DefaultApiFp(this.configuration).getProfilingGroupDetail(
      groupId,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Get download token with a given group ID
   * @summary Get download token for group download
   * @param {string} [id] group ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getProfilingGroupDownloadToken(id?: string, options?: any) {
    return DefaultApiFp(this.configuration).getProfilingGroupDownloadToken(
      id,
      options
    )(this.axios, this.basePath)
  }

  /**
   * List all profiling groups
   * @summary List all profiling groups
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getProfilingGroups(options?: any) {
    return DefaultApiFp(this.configuration).getProfilingGroups(options)(
      this.axios,
      this.basePath
    )
  }

  /**
   * Get download token with a given task ID
   * @summary Get download token for single download
   * @param {string} [id] task ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getProfilingSingleDownloadToken(id?: string, options?: any) {
    return DefaultApiFp(this.configuration).getProfilingSingleDownloadToken(
      id,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Get all databases.
   * @summary Example: Get all databases
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public infoDatabasesGet(options?: any) {
    return DefaultApiFp(this.configuration).infoDatabasesGet(options)(
      this.axios,
      this.basePath
    )
  }

  /**
   * Get current login session
   * @summary Current login
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public infoWhoamiGet(options?: any) {
    return DefaultApiFp(this.configuration).infoWhoamiGet(options)(
      this.axios,
      this.basePath
    )
  }

  /**
   * Heatmaps in a given range to visualize TiKV usage
   * @summary Key Visual Heatmaps
   * @param {string} [startkey] The start of the key range
   * @param {string} [endkey] The end of the key range
   * @param {number} [starttime] The start of the time range (Unix)
   * @param {number} [endtime] The end of the time range (Unix)
   * @param {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'} [type] Main types of data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public keyvisualHeatmapsGet(
    startkey?: string,
    endkey?: string,
    starttime?: number,
    endtime?: number,
    type?:
      | 'written_bytes'
      | 'read_bytes'
      | 'written_keys'
      | 'read_keys'
      | 'integration',
    options?: any
  ) {
    return DefaultApiFp(this.configuration).keyvisualHeatmapsGet(
      startkey,
      endkey,
      starttime,
      endtime,
      type,
      options
    )(this.axios, this.basePath)
  }

  /**
   * get download token with multiple task IDs
   * @summary Get download token
   * @param {Array<string>} [id] task id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public logsDownloadAcquireTokenGet(id?: Array<string>, options?: any) {
    return DefaultApiFp(this.configuration).logsDownloadAcquireTokenGet(
      id,
      options
    )(this.axios, this.basePath)
  }

  /**
   * download logs by multiple task IDs
   * @summary Download
   * @param {string} token download token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public logsDownloadGet(token: string, options?: any) {
    return DefaultApiFp(this.configuration).logsDownloadGet(token, options)(
      this.axios,
      this.basePath
    )
  }

  /**
   * Create and run task group
   * @summary Create and run task group
   * @param {LogsearchCreateTaskGroupRequest} request Request body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public logsTaskgroupPut(
    request: LogsearchCreateTaskGroupRequest,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).logsTaskgroupPut(request, options)(
      this.axios,
      this.basePath
    )
  }

  /**
   * list all log search taskgroups
   * @summary List all task groups
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public logsTaskgroupsGet(options?: any) {
    return DefaultApiFp(this.configuration).logsTaskgroupsGet(options)(
      this.axios,
      this.basePath
    )
  }

  /**
   * cancel all running tasks in a task group
   * @summary Cancel running tasks
   * @param {string} id task group id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public logsTaskgroupsIdCancelPost(id: string, options?: any) {
    return DefaultApiFp(this.configuration).logsTaskgroupsIdCancelPost(
      id,
      options
    )(this.axios, this.basePath)
  }

  /**
   * delete a task group by providing task group ID
   * @summary Delete task group
   * @param {string} id task group id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public logsTaskgroupsIdDelete(id: string, options?: any) {
    return DefaultApiFp(this.configuration).logsTaskgroupsIdDelete(id, options)(
      this.axios,
      this.basePath
    )
  }

  /**
   * list all log search tasks in a task group by providing task group ID
   * @summary List tasks in a task group
   * @param {string} id Task Group ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public logsTaskgroupsIdGet(id: string, options?: any) {
    return DefaultApiFp(this.configuration).logsTaskgroupsIdGet(id, options)(
      this.axios,
      this.basePath
    )
  }

  /**
   * preview fetched logs in a task group by providing task group ID
   * @summary Preview logs in a task group
   * @param {string} id task group id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public logsTaskgroupsIdPreviewGet(id: string, options?: any) {
    return DefaultApiFp(this.configuration).logsTaskgroupsIdPreviewGet(
      id,
      options
    )(this.axios, this.basePath)
  }

  /**
   * retry tasks that has been failed in a task group
   * @summary Retry failed tasks
   * @param {string} id task group id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public logsTaskgroupsIdRetryPost(id: string, options?: any) {
    return DefaultApiFp(this.configuration).logsTaskgroupsIdRetryPost(
      id,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Start a profiling task group
   * @summary Start profiling
   * @param {ProfilingStartRequest} pr profiling request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public startProfiling(pr: ProfilingStartRequest, options?: any) {
    return DefaultApiFp(this.configuration).startProfiling(pr, options)(
      this.axios,
      this.basePath
    )
  }

  /**
   * Get statement detail
   * @summary Statement detail
   * @param {string} schema Statement schema
   * @param {string} begin_time Statement begin time
   * @param {string} end_time Statement end time
   * @param {string} digest Statement digest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public statementsDetailGet(
    schema: string,
    begin_time: string,
    end_time: string,
    digest: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).statementsDetailGet(
      schema,
      begin_time,
      end_time,
      digest,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Get statement in each node
   * @summary Statement nodes
   * @param {string} schema Statement schema
   * @param {string} begin_time Statement begin time
   * @param {string} end_time Statement end time
   * @param {string} digest Statement digest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public statementsNodesGet(
    schema: string,
    begin_time: string,
    end_time: string,
    digest: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).statementsNodesGet(
      schema,
      begin_time,
      end_time,
      digest,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Get statements overview
   * @summary Statements overview
   * @param {string} begin_time Statement begin time
   * @param {string} end_time Statement end time
   * @param {string} [schemas] Target schemas
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public statementsOverviewsGet(
    begin_time: string,
    end_time: string,
    schemas?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).statementsOverviewsGet(
      begin_time,
      end_time,
      schemas,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Get all databases of TiDB
   * @summary TiDB databases
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public statementsSchemasGet(options?: any) {
    return DefaultApiFp(this.configuration).statementsSchemasGet(options)(
      this.axios,
      this.basePath
    )
  }

  /**
   * Get all time ranges of the statements
   * @summary Statement time ranges
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public statementsTimeRangesGet(options?: any) {
    return DefaultApiFp(this.configuration).statementsTimeRangesGet(options)(
      this.axios,
      this.basePath
    )
  }

  /**
   * Get alert number of the alert manager.
   * @summary Get the count of alert
   * @param {string} address ip:port
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public topologyAlertmanagerAddressCountGet(address: string, options?: any) {
    return DefaultApiFp(this.configuration).topologyAlertmanagerAddressCountGet(
      address,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Get information about the dashboard topology.
   * @summary Get all Dashboard topology and liveness.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public topologyAllGet(options?: any) {
    return DefaultApiFp(this.configuration).topologyAllGet(options)(
      this.axios,
      this.basePath
    )
  }

  /**
   * Delete etcd\'s TiDB key with ip:port.
   * @summary Delete etcd\'s tidb key.
   * @param {string} address ip:port
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public topologyTidbAddressDelete(address: string, options?: any) {
    return DefaultApiFp(this.configuration).topologyTidbAddressDelete(
      address,
      options
    )(this.axios, this.basePath)
  }

  /**
   * Log into dashboard.
   * @summary Log in
   * @param {UserAuthenticateForm} message Credentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public userLoginPost(message: UserAuthenticateForm, options?: any) {
    return DefaultApiFp(this.configuration).userLoginPost(message, options)(
      this.axios,
      this.basePath
    )
  }
}
