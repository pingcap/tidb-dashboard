/* tslint:disable */
/* eslint-disable */
/**
 * Dashboard API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ClusterinfoClusterStatistics } from '../models';
// @ts-ignore
import { ClusterinfoGetHostsInfoResponse } from '../models';
// @ts-ignore
import { ClusterinfoStoreTopologyResponse } from '../models';
// @ts-ignore
import { CodeShareRequest } from '../models';
// @ts-ignore
import { CodeShareResponse } from '../models';
// @ts-ignore
import { ConfigKeyVisualConfig } from '../models';
// @ts-ignore
import { ConfigProfilingConfig } from '../models';
// @ts-ignore
import { ConfigSSOCoreConfig } from '../models';
// @ts-ignore
import { ConfigurationAllConfigItems } from '../models';
// @ts-ignore
import { ConfigurationEditRequest } from '../models';
// @ts-ignore
import { ConfigurationEditResponse } from '../models';
// @ts-ignore
import { ConprofComponent } from '../models';
// @ts-ignore
import { ConprofEstimateSizeRes } from '../models';
// @ts-ignore
import { ConprofGroupProfileDetail } from '../models';
// @ts-ignore
import { ConprofGroupProfiles } from '../models';
// @ts-ignore
import { ConprofNgMonitoringConfig } from '../models';
// @ts-ignore
import { DeadlockModel } from '../models';
// @ts-ignore
import { DiagnoseGenDiagnosisReportRequest } from '../models';
// @ts-ignore
import { DiagnoseGenerateMetricsRelationRequest } from '../models';
// @ts-ignore
import { DiagnoseGenerateReportRequest } from '../models';
// @ts-ignore
import { DiagnoseReport } from '../models';
// @ts-ignore
import { DiagnoseTableDef } from '../models';
// @ts-ignore
import { EndpointAPIDefinition } from '../models';
// @ts-ignore
import { EndpointRequestPayload } from '../models';
// @ts-ignore
import { InfoInfoResponse } from '../models';
// @ts-ignore
import { InfoTableSchema } from '../models';
// @ts-ignore
import { InfoWhoAmIResponse } from '../models';
// @ts-ignore
import { LogsearchCreateTaskGroupRequest } from '../models';
// @ts-ignore
import { LogsearchPreviewModel } from '../models';
// @ts-ignore
import { LogsearchTaskGroupModel } from '../models';
// @ts-ignore
import { LogsearchTaskGroupResponse } from '../models';
// @ts-ignore
import { MatrixMatrix } from '../models';
// @ts-ignore
import { MetricsGetPromAddressConfigResponse } from '../models';
// @ts-ignore
import { MetricsPutCustomPromAddressRequest } from '../models';
// @ts-ignore
import { MetricsPutCustomPromAddressResponse } from '../models';
// @ts-ignore
import { MetricsQueryResponse } from '../models';
// @ts-ignore
import { ProfilingGroupDetailResponse } from '../models';
// @ts-ignore
import { ProfilingStartRequest } from '../models';
// @ts-ignore
import { ProfilingTaskGroupModel } from '../models';
// @ts-ignore
import { QueryeditorRunRequest } from '../models';
// @ts-ignore
import { QueryeditorRunResponse } from '../models';
// @ts-ignore
import { ResourcemanagerCalibrateResponse } from '../models';
// @ts-ignore
import { ResourcemanagerGetConfigResponse } from '../models';
// @ts-ignore
import { ResourcemanagerResourceInfoRowDef } from '../models';
// @ts-ignore
import { RestErrorResponse } from '../models';
// @ts-ignore
import { SlowqueryGetListRequest } from '../models';
// @ts-ignore
import { SlowqueryModel } from '../models';
// @ts-ignore
import { SsoCreateImpersonationRequest } from '../models';
// @ts-ignore
import { SsoSSOImpersonationModel } from '../models';
// @ts-ignore
import { SsoSetConfigRequest } from '../models';
// @ts-ignore
import { StatementBinding } from '../models';
// @ts-ignore
import { StatementEditableConfig } from '../models';
// @ts-ignore
import { StatementGetStatementsRequest } from '../models';
// @ts-ignore
import { StatementModel } from '../models';
// @ts-ignore
import { TopologyAlertManagerInfo } from '../models';
// @ts-ignore
import { TopologyGrafanaInfo } from '../models';
// @ts-ignore
import { TopologyPDInfo } from '../models';
// @ts-ignore
import { TopologySchedulingInfo } from '../models';
// @ts-ignore
import { TopologyStoreLocation } from '../models';
// @ts-ignore
import { TopologyTSOInfo } from '../models';
// @ts-ignore
import { TopologyTiCDCInfo } from '../models';
// @ts-ignore
import { TopologyTiDBInfo } from '../models';
// @ts-ignore
import { TopologyTiProxyInfo } from '../models';
// @ts-ignore
import { TopsqlEditableConfig } from '../models';
// @ts-ignore
import { TopsqlInstanceResponse } from '../models';
// @ts-ignore
import { TopsqlSummaryResponse } from '../models';
// @ts-ignore
import { UserAuthenticateForm } from '../models';
// @ts-ignore
import { UserGetLoginInfoResponse } from '../models';
// @ts-ignore
import { UserSignOutInfo } from '../models';
// @ts-ignore
import { UserTokenResponse } from '../models';
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel all profling tasks with a given group ID
         * @summary Cancel all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelProfilingGroup: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('cancelProfilingGroup', 'groupId', groupId)
            const localVarPath = `/profiling/group/cancel/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information of all hosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterInfoGetHostsInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/host/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterInfoGetStatistics: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/host/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a configuration
         * @param {ConfigurationEditRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurationEdit: async (request: ConfigurationEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('configurationEdit', 'request', request)
            const localVarPath = `/configuration/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurationGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/configuration/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get action token for download or view profile
         * @param {string} q target query string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingActionTokenGet: async (q: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('continuousProfilingActionTokenGet', 'q', q)
            const localVarPath = `/continuous_profiling/action_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current scraping components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingComponentsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/continuous_profiling/components`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Continuous Profiling Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/continuous_profiling/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Continuous Profiling Config
         * @param {ConprofNgMonitoringConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingConfigPost: async (request: ConprofNgMonitoringConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('continuousProfilingConfigPost', 'request', request)
            const localVarPath = `/continuous_profiling/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Group Profile files
         * @param {number} ts timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingDownloadGet: async (ts: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ts' is not null or undefined
            assertParamExists('continuousProfilingDownloadGet', 'ts', ts)
            const localVarPath = `/continuous_profiling/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ts !== undefined) {
                localVarQueryParameter['ts'] = ts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Estimate Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingEstimateSizeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/continuous_profiling/estimate_size`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Group Profile Detail
         * @param {number} ts timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingGroupProfileDetailGet: async (ts: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ts' is not null or undefined
            assertParamExists('continuousProfilingGroupProfileDetailGet', 'ts', ts)
            const localVarPath = `/continuous_profiling/group_profile/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ts !== undefined) {
                localVarQueryParameter['ts'] = ts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Group Profiles
         * @param {number} [beginTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingGroupProfilesGet: async (beginTime?: number, endTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/continuous_profiling/group_profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (beginTime !== undefined) {
                localVarQueryParameter['begin_time'] = beginTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View Single Profile files
         * @param {string} [address] 
         * @param {string} [component] 
         * @param {string} [profileType] 
         * @param {number} [ts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingSingleProfileViewGet: async (address?: string, component?: string, profileType?: string, ts?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/continuous_profiling/single_profile/view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (component !== undefined) {
                localVarQueryParameter['component'] = component;
            }

            if (profileType !== undefined) {
                localVarQueryParameter['profile_type'] = profileType;
            }

            if (ts !== undefined) {
                localVarQueryParameter['ts'] = ts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all deadlock records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deadlockListGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deadlock/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugAPIGetEndpoints: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/debug_api/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send request remote endpoint and return a token for downloading results
         * @param {EndpointRequestPayload} req request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugAPIRequestEndpoint: async (req: EndpointRequestPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('debugAPIRequestEndpoint', 'req', req)
            const localVarPath = `/debug_api/endpoint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a finished request result
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugApiDownloadGet: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('debugApiDownloadGet', 'token', token)
            const localVarPath = `/debug_api/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all finished profiling tasks with a given group ID
         * @summary Delete all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfilingGroup: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteProfilingGroup', 'groupId', groupId)
            const localVarPath = `/profiling/group/delete/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate sql diagnosis report
         * @summary SQL diagnosis report
         * @param {DiagnoseGenDiagnosisReportRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseDiagnosisPost: async (request: DiagnoseGenDiagnosisReportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('diagnoseDiagnosisPost', 'request', request)
            const localVarPath = `/diagnose/diagnosis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate metrics relationship graph.
         * @param {DiagnoseGenerateMetricsRelationRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseGenerateMetricsRelationship: async (request: DiagnoseGenerateMetricsRelationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('diagnoseGenerateMetricsRelationship', 'request', request)
            const localVarPath = `/diagnose/metrics_relation/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View metrics relationship graph.
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseMetricsRelationViewGet: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('diagnoseMetricsRelationViewGet', 'token', token)
            const localVarPath = `/diagnose/metrics_relation/view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sql diagnosis reports history
         * @summary SQL diagnosis reports history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/diagnose/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sql diagnosis report data
         * @summary SQL diagnosis report data
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdDataJsGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('diagnoseReportsIdDataJsGet', 'id', id)
            const localVarPath = `/diagnose/reports/{id}/data.js`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sql diagnosis report HTML
         * @summary SQL diagnosis report
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdDetailGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('diagnoseReportsIdDetailGet', 'id', id)
            const localVarPath = `/diagnose/reports/{id}/detail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get diagnosis report status
         * @summary Diagnosis report status
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdStatusGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('diagnoseReportsIdStatusGet', 'id', id)
            const localVarPath = `/diagnose/reports/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate sql diagnosis report
         * @summary SQL diagnosis report
         * @param {DiagnoseGenerateReportRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsPost: async (request: DiagnoseGenerateReportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('diagnoseReportsPost', 'request', request)
            const localVarPath = `/diagnose/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download all finished profiling results of a task group
         * @summary Download all results of a task group
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProfilingGroup: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('downloadProfilingGroup', 'token', token)
            const localVarPath = `/profiling/group/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download the finished profiling result of a task
         * @summary Download the result of a task
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProfilingSingle: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('downloadProfilingSingle', 'token', token)
            const localVarPath = `/profiling/single/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get token with a given group ID or task ID and action type
         * @summary Get action token for download or view
         * @param {string} [id] group or task ID
         * @param {string} [action] action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionToken: async (id?: string, action?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiling/action_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current alert count from AlertManager
         * @param {string} address ip:port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertManagerCounts: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAlertManagerCounts', 'address', address)
            const localVarPath = `/topology/alertmanager/{address}/count`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get AlertManager instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertManagerTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/alertmanager`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Grafana instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrafanaTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/grafana`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all PD instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPDTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/pd`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all profiling tasks with a given group ID
         * @summary List all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroupDetail: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getProfilingGroupDetail', 'groupId', groupId)
            const localVarPath = `/profiling/group/detail/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all profiling groups
         * @summary List all profiling groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiling/group/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Scheduling instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulingTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/scheduling`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get location labels of all TiKV / TiFlash instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreLocationTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/store_location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all TiKV / TiFlash instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all TSO instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTSOTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/tso`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all TiCDC instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiCDCTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/ticdc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all TiDB instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiDBTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/tidb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all TiProxy instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiProxyTopology: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topology/tiproxy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about this TiDB Dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all databases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoListDatabases: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info/databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tables by database name
         * @param {string} [databaseName] Database name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoListTables: async (databaseName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info/tables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (databaseName !== undefined) {
                localVarQueryParameter['database_name'] = databaseName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoWhoami: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Key Visual Dynamic Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyvisualConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/keyvisual/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Key Visual Dynamic Config
         * @param {ConfigKeyVisualConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyvisualConfigPut: async (request: ConfigKeyVisualConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('keyvisualConfigPut', 'request', request)
            const localVarPath = `/keyvisual/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Heatmaps in a given range to visualize TiKV usage
         * @summary Key Visual Heatmaps
         * @param {string} [startkey] The start of the key range
         * @param {string} [endkey] The end of the key range
         * @param {number} [starttime] The start of the time range (Unix)
         * @param {number} [endtime] The end of the time range (Unix)
         * @param {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'} [type] Main types of data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyvisualHeatmapsGet: async (startkey?: string, endkey?: string, starttime?: number, endtime?: number, type?: 'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/keyvisual/heatmaps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (startkey !== undefined) {
                localVarQueryParameter['startkey'] = startkey;
            }

            if (endkey !== undefined) {
                localVarQueryParameter['endkey'] = endkey;
            }

            if (starttime !== undefined) {
                localVarQueryParameter['starttime'] = starttime;
            }

            if (endtime !== undefined) {
                localVarQueryParameter['endtime'] = endtime;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a download token for downloading logs
         * @param {Array<string>} [id] task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsDownloadAcquireTokenGet: async (id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logs/download/acquire_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id) {
                localVarQueryParameter['id'] = id.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download logs
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsDownloadGet: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('logsDownloadGet', 'token', token)
            const localVarPath = `/logs/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create and run a new log search task group
         * @param {LogsearchCreateTaskGroupRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupPut: async (request: LogsearchCreateTaskGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('logsTaskgroupPut', 'request', request)
            const localVarPath = `/logs/taskgroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all log search task groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logs/taskgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel running tasks in a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdCancelPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logsTaskgroupsIdCancelPost', 'id', id)
            const localVarPath = `/logs/taskgroups/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logsTaskgroupsIdDelete', 'id', id)
            const localVarPath = `/logs/taskgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tasks in a log search task group
         * @param {string} id Task Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logsTaskgroupsIdGet', 'id', id)
            const localVarPath = `/logs/taskgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Preview a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdPreviewGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logsTaskgroupsIdPreviewGet', 'id', id)
            const localVarPath = `/logs/taskgroups/{id}/preview`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retry failed tasks in a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdRetryPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logsTaskgroupsIdRetryPost', 'id', id)
            const localVarPath = `/logs/taskgroups/{id}/retry`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Prometheus address cluster config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGetPromAddress: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics/prom_address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query metrics in the given range
         * @summary Query metrics
         * @param {number} [endTimeSec] 
         * @param {string} [query] 
         * @param {number} [startTimeSec] 
         * @param {number} [stepSec] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsQueryGet: async (endTimeSec?: number, query?: string, startTimeSec?: number, stepSec?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endTimeSec !== undefined) {
                localVarQueryParameter['end_time_sec'] = endTimeSec;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (startTimeSec !== undefined) {
                localVarQueryParameter['start_time_sec'] = startTimeSec;
            }

            if (stepSec !== undefined) {
                localVarQueryParameter['step_sec'] = stepSec;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set or clear the customized Prometheus address
         * @param {MetricsPutCustomPromAddressRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsSetCustomPromAddress: async (request: MetricsPutCustomPromAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('metricsSetCustomPromAddress', 'request', request)
            const localVarPath = `/metrics/prom_address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Profiling Dynamic Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiling/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Profiling Dynamic Config
         * @param {ConfigProfilingConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingConfigPut: async (request: ConfigProfilingConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('profilingConfigPut', 'request', request)
            const localVarPath = `/profiling/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run statements
         * @param {QueryeditorRunRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryEditorRun: async (request: QueryeditorRunRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('queryEditorRun', 'request', request)
            const localVarPath = `/query_editor/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get calibrate of Resource Groups by actual workload
         * @param {number} [endTime] 
         * @param {number} [startTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceManagerCalibrateActualGet: async (endTime?: number, startTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resource_manager/calibrate/actual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get calibrate of Resource Groups by hardware deployment
         * @param {string} workload workload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceManagerCalibrateHardwareGet: async (workload: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workload' is not null or undefined
            assertParamExists('resourceManagerCalibrateHardwareGet', 'workload', workload)
            const localVarPath = `/resource_manager/calibrate/hardware`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (workload !== undefined) {
                localVarQueryParameter['workload'] = workload;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Resource Control enable config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceManagerConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resource_manager/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Information of Resource Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceManagerInformationGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resource_manager/information`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all resource groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceManagerInformationGroupNamesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resource_manager/information/group_names`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get available field names by slowquery table columns
         * @summary Get available field names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryAvailableFieldsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slow_query/available_fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a slow query
         * @param {string} [connectId] TODO: Switch back to uint64 when modern browser as well as Swagger handles BigInt well.
         * @param {string} [digest] 
         * @param {number} [timestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryDetailGet: async (connectId?: string, digest?: string, timestamp?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slow_query/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (connectId !== undefined) {
                localVarQueryParameter['connect_id'] = connectId;
            }

            if (digest !== undefined) {
                localVarQueryParameter['digest'] = digest;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download slow query statements
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryDownloadGet: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('slowQueryDownloadGet', 'token', token)
            const localVarPath = `/slow_query/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a download token for exported slow query statements
         * @param {SlowqueryGetListRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryDownloadTokenPost: async (request: SlowqueryGetListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('slowQueryDownloadTokenPost', 'request', request)
            const localVarPath = `/slow_query/download/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all slow queries
         * @param {number} [beginTime] 
         * @param {Array<string>} [db] 
         * @param {boolean} [desc] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {string} [fields] example: \&quot;Query,Digest\&quot;
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {Array<string>} [plans] for showing slow queries in the statement detail page
         * @param {Array<string>} [resourceGroup] 
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryListGet: async (beginTime?: number, db?: Array<string>, desc?: boolean, digest?: string, endTime?: number, fields?: string, limit?: number, orderBy?: string, plans?: Array<string>, resourceGroup?: Array<string>, text?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slow_query/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (beginTime !== undefined) {
                localVarQueryParameter['begin_time'] = beginTime;
            }

            if (db) {
                localVarQueryParameter['db'] = db;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (digest !== undefined) {
                localVarQueryParameter['digest'] = digest;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (plans) {
                localVarQueryParameter['plans'] = plans;
            }

            if (resourceGroup) {
                localVarQueryParameter['resource_group'] = resourceGroup;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a profiling task group
         * @summary Start profiling
         * @param {ProfilingStartRequest} req profiling request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProfiling: async (req: ProfilingStartRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('startProfiling', 'req', req)
            const localVarPath = `/profiling/group/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get available field names by statements table columns
         * @summary Get available field names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsAvailableFieldsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/available_fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get statement configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update statement configurations
         * @param {StatementEditableConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsConfigPost: async (request: StatementEditableConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('statementsConfigPost', 'request', request)
            const localVarPath = `/statements/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download statements
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsDownloadGet: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('statementsDownloadGet', 'token', token)
            const localVarPath = `/statements/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a download token for exported statements
         * @param {StatementGetStatementsRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsDownloadTokenPost: async (request: StatementGetStatementsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('statementsDownloadTokenPost', 'request', request)
            const localVarPath = `/statements/download/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of statements
         * @param {number} [beginTime] 
         * @param {number} [endTime] 
         * @param {string} [fields] 
         * @param {Array<string>} [resourceGroups] 
         * @param {Array<string>} [schemas] 
         * @param {Array<string>} [stmtTypes] 
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsListGet: async (beginTime?: number, endTime?: number, fields?: string, resourceGroups?: Array<string>, schemas?: Array<string>, stmtTypes?: Array<string>, text?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (beginTime !== undefined) {
                localVarQueryParameter['begin_time'] = beginTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (resourceGroups) {
                localVarQueryParameter['resource_groups'] = resourceGroups;
            }

            if (schemas) {
                localVarQueryParameter['schemas'] = schemas;
            }

            if (stmtTypes) {
                localVarQueryParameter['stmt_types'] = stmtTypes;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Drop all manually created bindings for a statement
         * @param {string} sqlDigest query template ID (a.k.a. sql digest)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsPlanBindingDelete: async (sqlDigest: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sqlDigest' is not null or undefined
            assertParamExists('statementsPlanBindingDelete', 'sqlDigest', sqlDigest)
            const localVarPath = `/statements/plan/binding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (sqlDigest !== undefined) {
                localVarQueryParameter['sql_digest'] = sqlDigest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the bound plan digest (if exists) of a statement
         * @param {string} sqlDigest query template id
         * @param {number} beginTime begin time
         * @param {number} endTime end time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsPlanBindingGet: async (sqlDigest: string, beginTime: number, endTime: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sqlDigest' is not null or undefined
            assertParamExists('statementsPlanBindingGet', 'sqlDigest', sqlDigest)
            // verify required parameter 'beginTime' is not null or undefined
            assertParamExists('statementsPlanBindingGet', 'beginTime', beginTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('statementsPlanBindingGet', 'endTime', endTime)
            const localVarPath = `/statements/plan/binding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (sqlDigest !== undefined) {
                localVarQueryParameter['sql_digest'] = sqlDigest;
            }

            if (beginTime !== undefined) {
                localVarQueryParameter['begin_time'] = beginTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a binding for a statement and a plan
         * @param {string} planDigest plan digest id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsPlanBindingPost: async (planDigest: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planDigest' is not null or undefined
            assertParamExists('statementsPlanBindingPost', 'planDigest', planDigest)
            const localVarPath = `/statements/plan/binding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (planDigest !== undefined) {
                localVarQueryParameter['plan_digest'] = planDigest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a statement in an execution plan
         * @param {number} [beginTime] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {Array<string>} [plans] 
         * @param {string} [schemaName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsPlanDetailGet: async (beginTime?: number, digest?: string, endTime?: number, plans?: Array<string>, schemaName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/plan/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (beginTime !== undefined) {
                localVarQueryParameter['begin_time'] = beginTime;
            }

            if (digest !== undefined) {
                localVarQueryParameter['digest'] = digest;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (plans) {
                localVarQueryParameter['plans'] = plans;
            }

            if (schemaName !== undefined) {
                localVarQueryParameter['schema_name'] = schemaName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get execution plans of a statement
         * @param {number} [beginTime] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {string} [schemaName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsPlansGet: async (beginTime?: number, digest?: string, endTime?: number, schemaName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (beginTime !== undefined) {
                localVarQueryParameter['begin_time'] = beginTime;
            }

            if (digest !== undefined) {
                localVarQueryParameter['digest'] = digest;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (schemaName !== undefined) {
                localVarQueryParameter['schema_name'] = schemaName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all statement types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsStmtTypesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/stmt_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Hide a TiDB instance
         * @param {string} address ip:port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topologyTidbAddressDelete: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('topologyTidbAddressDelete', 'address', address)
            const localVarPath = `/topology/tidb/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Top SQL config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topsql/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Top SQL config
         * @param {TopsqlEditableConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlConfigPost: async (request: TopsqlEditableConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('topsqlConfigPost', 'request', request)
            const localVarPath = `/topsql/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get availiable instances
         * @param {string} [end] 
         * @param {string} [start] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlInstancesGet: async (end?: string, start?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topsql/instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get summaries
         * @param {string} [end] 
         * @param {string} [groupBy] 
         * @param {string} [instance] 
         * @param {string} [instanceType] 
         * @param {string} [start] 
         * @param {string} [top] 
         * @param {string} [window] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlSummaryGet: async (end?: string, groupBy?: string, instance?: string, instanceType?: string, start?: string, top?: string, window?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topsql/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (instance !== undefined) {
                localVarQueryParameter['instance'] = instance;
            }

            if (instanceType !== undefined) {
                localVarQueryParameter['instance_type'] = instanceType;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (top !== undefined) {
                localVarQueryParameter['top'] = top;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get log in information, like supported authenticate types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetLoginInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/login_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get sign out info
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetSignOutInfo: async (redirectUrl?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/sign_out_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (redirectUrl !== undefined) {
                localVarQueryParameter['redirect_url'] = redirectUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Log in
         * @param {UserAuthenticateForm} message Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin: async (message: UserAuthenticateForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('userLogin', 'message', message)
            const localVarPath = `/user/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset encryption key to revoke all authorized codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRevokeSession: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/share/revoke`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an impersonation
         * @param {SsoCreateImpersonationRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOCreateImpersonation: async (request: SsoCreateImpersonationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('userSSOCreateImpersonation', 'request', request)
            const localVarPath = `/user/sso/impersonation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get SSO Auth URL
         * @param {string} [codeVerifier] 
         * @param {string} [redirectUrl] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOGetAuthURL: async (codeVerifier?: string, redirectUrl?: string, state?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/sso/auth_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (codeVerifier !== undefined) {
                localVarQueryParameter['code_verifier'] = codeVerifier;
            }

            if (redirectUrl !== undefined) {
                localVarQueryParameter['redirect_url'] = redirectUrl;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get SSO config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOGetConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/sso/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all impersonations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOListImpersonations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/sso/impersonations/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set SSO config
         * @param {SsoSetConfigRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOSetConfig: async (request: SsoSetConfigRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('userSSOSetConfig', 'request', request)
            const localVarPath = `/user/sso/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Share current session and generate a sharing code
         * @param {CodeShareRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareSession: async (request: CodeShareRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('userShareSession', 'request', request)
            const localVarPath = `/user/share/code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View the finished profiling result of a task
         * @summary View the result of a task
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewProfilingSingle: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('viewProfilingSingle', 'token', token)
            const localVarPath = `/profiling/single/view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel all profling tasks with a given group ID
         * @summary Cancel all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelProfilingGroup(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelProfilingGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get information of all hosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterInfoGetHostsInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterinfoGetHostsInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterInfoGetHostsInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get cluster statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterInfoGetStatistics(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterinfoClusterStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterInfoGetStatistics(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a configuration
         * @param {ConfigurationEditRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configurationEdit(request: ConfigurationEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationEditResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configurationEdit(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configurationGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationAllConfigItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configurationGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get action token for download or view profile
         * @param {string} q target query string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingActionTokenGet(q: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingActionTokenGet(q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get current scraping components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingComponentsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConprofComponent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingComponentsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Continuous Profiling Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingConfigGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConprofNgMonitoringConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingConfigGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Continuous Profiling Config
         * @param {ConprofNgMonitoringConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingConfigPost(request: ConprofNgMonitoringConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingConfigPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download Group Profile files
         * @param {number} ts timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingDownloadGet(ts: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingDownloadGet(ts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Estimate Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingEstimateSizeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConprofEstimateSizeRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingEstimateSizeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Group Profile Detail
         * @param {number} ts timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingGroupProfileDetailGet(ts: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConprofGroupProfileDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingGroupProfileDetailGet(ts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Group Profiles
         * @param {number} [beginTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingGroupProfilesGet(beginTime?: number, endTime?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConprofGroupProfiles>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingGroupProfilesGet(beginTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View Single Profile files
         * @param {string} [address] 
         * @param {string} [component] 
         * @param {string} [profileType] 
         * @param {number} [ts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuousProfilingSingleProfileViewGet(address?: string, component?: string, profileType?: string, ts?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuousProfilingSingleProfileViewGet(address, component, profileType, ts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all deadlock records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deadlockListGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeadlockModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deadlockListGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debugAPIGetEndpoints(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EndpointAPIDefinition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debugAPIGetEndpoints(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send request remote endpoint and return a token for downloading results
         * @param {EndpointRequestPayload} req request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debugAPIRequestEndpoint(req: EndpointRequestPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debugAPIRequestEndpoint(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download a finished request result
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debugApiDownloadGet(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debugApiDownloadGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete all finished profiling tasks with a given group ID
         * @summary Delete all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfilingGroup(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProfilingGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate sql diagnosis report
         * @summary SQL diagnosis report
         * @param {DiagnoseGenDiagnosisReportRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseDiagnosisPost(request: DiagnoseGenDiagnosisReportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiagnoseTableDef>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseDiagnosisPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate metrics relationship graph.
         * @param {DiagnoseGenerateMetricsRelationRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseGenerateMetricsRelationship(request: DiagnoseGenerateMetricsRelationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseGenerateMetricsRelationship(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View metrics relationship graph.
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseMetricsRelationViewGet(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseMetricsRelationViewGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get sql diagnosis reports history
         * @summary SQL diagnosis reports history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseReportsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DiagnoseReport>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseReportsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get sql diagnosis report data
         * @summary SQL diagnosis report data
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseReportsIdDataJsGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseReportsIdDataJsGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get sql diagnosis report HTML
         * @summary SQL diagnosis report
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseReportsIdDetailGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseReportsIdDetailGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get diagnosis report status
         * @summary Diagnosis report status
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseReportsIdStatusGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiagnoseReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseReportsIdStatusGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate sql diagnosis report
         * @summary SQL diagnosis report
         * @param {DiagnoseGenerateReportRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseReportsPost(request: DiagnoseGenerateReportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseReportsPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download all finished profiling results of a task group
         * @summary Download all results of a task group
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadProfilingGroup(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadProfilingGroup(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download the finished profiling result of a task
         * @summary Download the result of a task
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadProfilingSingle(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadProfilingSingle(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get token with a given group ID or task ID and action type
         * @summary Get action token for download or view
         * @param {string} [id] group or task ID
         * @param {string} [action] action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionToken(id?: string, action?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActionToken(id, action, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get current alert count from AlertManager
         * @param {string} address ip:port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlertManagerCounts(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertManagerCounts(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get AlertManager instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlertManagerTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopologyAlertManagerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertManagerTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Grafana instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrafanaTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopologyGrafanaInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGrafanaTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all PD instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPDTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopologyPDInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPDTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all profiling tasks with a given group ID
         * @summary List all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfilingGroupDetail(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilingGroupDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfilingGroupDetail(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all profiling groups
         * @summary List all profiling groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfilingGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProfilingTaskGroupModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfilingGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all Scheduling instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchedulingTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopologySchedulingInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchedulingTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get location labels of all TiKV / TiFlash instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoreLocationTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopologyStoreLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoreLocationTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all TiKV / TiFlash instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoreTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterinfoStoreTopologyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoreTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all TSO instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTSOTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopologyTSOInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTSOTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all TiCDC instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTiCDCTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopologyTiCDCInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTiCDCTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all TiDB instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTiDBTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopologyTiDBInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTiDBTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all TiProxy instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTiProxyTopology(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopologyTiProxyInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTiProxyTopology(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get information about this TiDB Dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all databases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoListDatabases(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoListDatabases(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List tables by database name
         * @param {string} [databaseName] Database name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoListTables(databaseName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InfoTableSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoListTables(databaseName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get information about current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoWhoami(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoWhoAmIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoWhoami(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Key Visual Dynamic Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyvisualConfigGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigKeyVisualConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyvisualConfigGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set Key Visual Dynamic Config
         * @param {ConfigKeyVisualConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyvisualConfigPut(request: ConfigKeyVisualConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigKeyVisualConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyvisualConfigPut(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Heatmaps in a given range to visualize TiKV usage
         * @summary Key Visual Heatmaps
         * @param {string} [startkey] The start of the key range
         * @param {string} [endkey] The end of the key range
         * @param {number} [starttime] The start of the time range (Unix)
         * @param {number} [endtime] The end of the time range (Unix)
         * @param {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'} [type] Main types of data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyvisualHeatmapsGet(startkey?: string, endkey?: string, starttime?: number, endtime?: number, type?: 'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatrixMatrix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyvisualHeatmapsGet(startkey, endkey, starttime, endtime, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate a download token for downloading logs
         * @param {Array<string>} [id] task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsDownloadAcquireTokenGet(id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsDownloadAcquireTokenGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download logs
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsDownloadGet(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsDownloadGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create and run a new log search task group
         * @param {LogsearchCreateTaskGroupRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsTaskgroupPut(request: LogsearchCreateTaskGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogsearchTaskGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsTaskgroupPut(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all log search task groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsTaskgroupsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogsearchTaskGroupModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsTaskgroupsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancel running tasks in a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsTaskgroupsIdCancelPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsTaskgroupsIdCancelPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsTaskgroupsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsTaskgroupsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List tasks in a log search task group
         * @param {string} id Task Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsTaskgroupsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogsearchTaskGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsTaskgroupsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Preview a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsTaskgroupsIdPreviewGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogsearchPreviewModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsTaskgroupsIdPreviewGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retry failed tasks in a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsTaskgroupsIdRetryPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsTaskgroupsIdRetryPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Prometheus address cluster config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGetPromAddress(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGetPromAddressConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGetPromAddress(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query metrics in the given range
         * @summary Query metrics
         * @param {number} [endTimeSec] 
         * @param {string} [query] 
         * @param {number} [startTimeSec] 
         * @param {number} [stepSec] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsQueryGet(endTimeSec?: number, query?: string, startTimeSec?: number, stepSec?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsQueryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsQueryGet(endTimeSec, query, startTimeSec, stepSec, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set or clear the customized Prometheus address
         * @param {MetricsPutCustomPromAddressRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsSetCustomPromAddress(request: MetricsPutCustomPromAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsPutCustomPromAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsSetCustomPromAddress(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Profiling Dynamic Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilingConfigGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigProfilingConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilingConfigGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set Profiling Dynamic Config
         * @param {ConfigProfilingConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilingConfigPut(request: ConfigProfilingConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigProfilingConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilingConfigPut(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Run statements
         * @param {QueryeditorRunRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryEditorRun(request: QueryeditorRunRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryeditorRunResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryEditorRun(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get calibrate of Resource Groups by actual workload
         * @param {number} [endTime] 
         * @param {number} [startTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceManagerCalibrateActualGet(endTime?: number, startTime?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourcemanagerCalibrateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourceManagerCalibrateActualGet(endTime, startTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get calibrate of Resource Groups by hardware deployment
         * @param {string} workload workload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceManagerCalibrateHardwareGet(workload: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourcemanagerCalibrateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourceManagerCalibrateHardwareGet(workload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Resource Control enable config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceManagerConfigGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourcemanagerGetConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourceManagerConfigGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Information of Resource Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceManagerInformationGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourcemanagerResourceInfoRowDef>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourceManagerInformationGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all resource groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceManagerInformationGroupNamesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourceManagerInformationGroupNamesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get available field names by slowquery table columns
         * @summary Get available field names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slowQueryAvailableFieldsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slowQueryAvailableFieldsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get details of a slow query
         * @param {string} [connectId] TODO: Switch back to uint64 when modern browser as well as Swagger handles BigInt well.
         * @param {string} [digest] 
         * @param {number} [timestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slowQueryDetailGet(connectId?: string, digest?: string, timestamp?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlowqueryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slowQueryDetailGet(connectId, digest, timestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download slow query statements
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slowQueryDownloadGet(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slowQueryDownloadGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate a download token for exported slow query statements
         * @param {SlowqueryGetListRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slowQueryDownloadTokenPost(request: SlowqueryGetListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slowQueryDownloadTokenPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all slow queries
         * @param {number} [beginTime] 
         * @param {Array<string>} [db] 
         * @param {boolean} [desc] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {string} [fields] example: \&quot;Query,Digest\&quot;
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {Array<string>} [plans] for showing slow queries in the statement detail page
         * @param {Array<string>} [resourceGroup] 
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slowQueryListGet(beginTime?: number, db?: Array<string>, desc?: boolean, digest?: string, endTime?: number, fields?: string, limit?: number, orderBy?: string, plans?: Array<string>, resourceGroup?: Array<string>, text?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SlowqueryModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slowQueryListGet(beginTime, db, desc, digest, endTime, fields, limit, orderBy, plans, resourceGroup, text, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start a profiling task group
         * @summary Start profiling
         * @param {ProfilingStartRequest} req profiling request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProfiling(req: ProfilingStartRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilingTaskGroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startProfiling(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get available field names by statements table columns
         * @summary Get available field names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsAvailableFieldsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsAvailableFieldsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get statement configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsConfigGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatementEditableConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsConfigGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update statement configurations
         * @param {StatementEditableConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsConfigPost(request: StatementEditableConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsConfigPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download statements
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsDownloadGet(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsDownloadGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate a download token for exported statements
         * @param {StatementGetStatementsRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsDownloadTokenPost(request: StatementGetStatementsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsDownloadTokenPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of statements
         * @param {number} [beginTime] 
         * @param {number} [endTime] 
         * @param {string} [fields] 
         * @param {Array<string>} [resourceGroups] 
         * @param {Array<string>} [schemas] 
         * @param {Array<string>} [stmtTypes] 
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsListGet(beginTime?: number, endTime?: number, fields?: string, resourceGroups?: Array<string>, schemas?: Array<string>, stmtTypes?: Array<string>, text?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatementModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsListGet(beginTime, endTime, fields, resourceGroups, schemas, stmtTypes, text, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Drop all manually created bindings for a statement
         * @param {string} sqlDigest query template ID (a.k.a. sql digest)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsPlanBindingDelete(sqlDigest: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsPlanBindingDelete(sqlDigest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the bound plan digest (if exists) of a statement
         * @param {string} sqlDigest query template id
         * @param {number} beginTime begin time
         * @param {number} endTime end time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsPlanBindingGet(sqlDigest: string, beginTime: number, endTime: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatementBinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsPlanBindingGet(sqlDigest, beginTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a binding for a statement and a plan
         * @param {string} planDigest plan digest id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsPlanBindingPost(planDigest: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsPlanBindingPost(planDigest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get details of a statement in an execution plan
         * @param {number} [beginTime] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {Array<string>} [plans] 
         * @param {string} [schemaName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsPlanDetailGet(beginTime?: number, digest?: string, endTime?: number, plans?: Array<string>, schemaName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatementModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsPlanDetailGet(beginTime, digest, endTime, plans, schemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get execution plans of a statement
         * @param {number} [beginTime] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {string} [schemaName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsPlansGet(beginTime?: number, digest?: string, endTime?: number, schemaName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatementModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsPlansGet(beginTime, digest, endTime, schemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all statement types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statementsStmtTypesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statementsStmtTypesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Hide a TiDB instance
         * @param {string} address ip:port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topologyTidbAddressDelete(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topologyTidbAddressDelete(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Top SQL config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topsqlConfigGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopsqlEditableConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topsqlConfigGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Top SQL config
         * @param {TopsqlEditableConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topsqlConfigPost(request: TopsqlEditableConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topsqlConfigPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get availiable instances
         * @param {string} [end] 
         * @param {string} [start] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topsqlInstancesGet(end?: string, start?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopsqlInstanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topsqlInstancesGet(end, start, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get summaries
         * @param {string} [end] 
         * @param {string} [groupBy] 
         * @param {string} [instance] 
         * @param {string} [instanceType] 
         * @param {string} [start] 
         * @param {string} [top] 
         * @param {string} [window] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topsqlSummaryGet(end?: string, groupBy?: string, instance?: string, instanceType?: string, start?: string, top?: string, window?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopsqlSummaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topsqlSummaryGet(end, groupBy, instance, instanceType, start, top, window, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get log in information, like supported authenticate types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetLoginInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetLoginInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetLoginInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get sign out info
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetSignOutInfo(redirectUrl?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSignOutInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetSignOutInfo(redirectUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Log in
         * @param {UserAuthenticateForm} message Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLogin(message: UserAuthenticateForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLogin(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset encryption key to revoke all authorized codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRevokeSession(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userRevokeSession(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an impersonation
         * @param {SsoCreateImpersonationRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSSOCreateImpersonation(request: SsoCreateImpersonationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoSSOImpersonationModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSSOCreateImpersonation(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get SSO Auth URL
         * @param {string} [codeVerifier] 
         * @param {string} [redirectUrl] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSSOGetAuthURL(codeVerifier?: string, redirectUrl?: string, state?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSSOGetAuthURL(codeVerifier, redirectUrl, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get SSO config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSSOGetConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigSSOCoreConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSSOGetConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all impersonations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSSOListImpersonations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SsoSSOImpersonationModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSSOListImpersonations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set SSO config
         * @param {SsoSetConfigRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSSOSetConfig(request: SsoSetConfigRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigSSOCoreConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSSOSetConfig(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Share current session and generate a sharing code
         * @param {CodeShareRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareSession(request: CodeShareRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodeShareResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareSession(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View the finished profiling result of a task
         * @summary View the result of a task
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewProfilingSingle(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewProfilingSingle(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Cancel all profling tasks with a given group ID
         * @summary Cancel all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelProfilingGroup(groupId: string, options?: any): AxiosPromise<object> {
            return localVarFp.cancelProfilingGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information of all hosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterInfoGetHostsInfo(options?: any): AxiosPromise<ClusterinfoGetHostsInfoResponse> {
            return localVarFp.clusterInfoGetHostsInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterInfoGetStatistics(options?: any): AxiosPromise<ClusterinfoClusterStatistics> {
            return localVarFp.clusterInfoGetStatistics(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a configuration
         * @param {ConfigurationEditRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurationEdit(request: ConfigurationEditRequest, options?: any): AxiosPromise<ConfigurationEditResponse> {
            return localVarFp.configurationEdit(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurationGetAll(options?: any): AxiosPromise<ConfigurationAllConfigItems> {
            return localVarFp.configurationGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get action token for download or view profile
         * @param {string} q target query string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingActionTokenGet(q: string, options?: any): AxiosPromise<string> {
            return localVarFp.continuousProfilingActionTokenGet(q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current scraping components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingComponentsGet(options?: any): AxiosPromise<Array<ConprofComponent>> {
            return localVarFp.continuousProfilingComponentsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Continuous Profiling Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingConfigGet(options?: any): AxiosPromise<ConprofNgMonitoringConfig> {
            return localVarFp.continuousProfilingConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Continuous Profiling Config
         * @param {ConprofNgMonitoringConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingConfigPost(request: ConprofNgMonitoringConfig, options?: any): AxiosPromise<string> {
            return localVarFp.continuousProfilingConfigPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Group Profile files
         * @param {number} ts timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingDownloadGet(ts: number, options?: any): AxiosPromise<void> {
            return localVarFp.continuousProfilingDownloadGet(ts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Estimate Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingEstimateSizeGet(options?: any): AxiosPromise<ConprofEstimateSizeRes> {
            return localVarFp.continuousProfilingEstimateSizeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Group Profile Detail
         * @param {number} ts timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingGroupProfileDetailGet(ts: number, options?: any): AxiosPromise<ConprofGroupProfileDetail> {
            return localVarFp.continuousProfilingGroupProfileDetailGet(ts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Group Profiles
         * @param {number} [beginTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingGroupProfilesGet(beginTime?: number, endTime?: number, options?: any): AxiosPromise<Array<ConprofGroupProfiles>> {
            return localVarFp.continuousProfilingGroupProfilesGet(beginTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View Single Profile files
         * @param {string} [address] 
         * @param {string} [component] 
         * @param {string} [profileType] 
         * @param {number} [ts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuousProfilingSingleProfileViewGet(address?: string, component?: string, profileType?: string, ts?: number, options?: any): AxiosPromise<void> {
            return localVarFp.continuousProfilingSingleProfileViewGet(address, component, profileType, ts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all deadlock records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deadlockListGet(options?: any): AxiosPromise<Array<DeadlockModel>> {
            return localVarFp.deadlockListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugAPIGetEndpoints(options?: any): AxiosPromise<Array<EndpointAPIDefinition>> {
            return localVarFp.debugAPIGetEndpoints(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send request remote endpoint and return a token for downloading results
         * @param {EndpointRequestPayload} req request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugAPIRequestEndpoint(req: EndpointRequestPayload, options?: any): AxiosPromise<string> {
            return localVarFp.debugAPIRequestEndpoint(req, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a finished request result
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugApiDownloadGet(token: string, options?: any): AxiosPromise<string> {
            return localVarFp.debugApiDownloadGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all finished profiling tasks with a given group ID
         * @summary Delete all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfilingGroup(groupId: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteProfilingGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate sql diagnosis report
         * @summary SQL diagnosis report
         * @param {DiagnoseGenDiagnosisReportRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseDiagnosisPost(request: DiagnoseGenDiagnosisReportRequest, options?: any): AxiosPromise<DiagnoseTableDef> {
            return localVarFp.diagnoseDiagnosisPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate metrics relationship graph.
         * @param {DiagnoseGenerateMetricsRelationRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseGenerateMetricsRelationship(request: DiagnoseGenerateMetricsRelationRequest, options?: any): AxiosPromise<string> {
            return localVarFp.diagnoseGenerateMetricsRelationship(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View metrics relationship graph.
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseMetricsRelationViewGet(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.diagnoseMetricsRelationViewGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get sql diagnosis reports history
         * @summary SQL diagnosis reports history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsGet(options?: any): AxiosPromise<Array<DiagnoseReport>> {
            return localVarFp.diagnoseReportsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get sql diagnosis report data
         * @summary SQL diagnosis report data
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdDataJsGet(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.diagnoseReportsIdDataJsGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get sql diagnosis report HTML
         * @summary SQL diagnosis report
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdDetailGet(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.diagnoseReportsIdDetailGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get diagnosis report status
         * @summary Diagnosis report status
         * @param {string} id report id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsIdStatusGet(id: string, options?: any): AxiosPromise<DiagnoseReport> {
            return localVarFp.diagnoseReportsIdStatusGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate sql diagnosis report
         * @summary SQL diagnosis report
         * @param {DiagnoseGenerateReportRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseReportsPost(request: DiagnoseGenerateReportRequest, options?: any): AxiosPromise<number> {
            return localVarFp.diagnoseReportsPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Download all finished profiling results of a task group
         * @summary Download all results of a task group
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProfilingGroup(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.downloadProfilingGroup(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Download the finished profiling result of a task
         * @summary Download the result of a task
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProfilingSingle(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.downloadProfilingSingle(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get token with a given group ID or task ID and action type
         * @summary Get action token for download or view
         * @param {string} [id] group or task ID
         * @param {string} [action] action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionToken(id?: string, action?: string, options?: any): AxiosPromise<string> {
            return localVarFp.getActionToken(id, action, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current alert count from AlertManager
         * @param {string} address ip:port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertManagerCounts(address: string, options?: any): AxiosPromise<number> {
            return localVarFp.getAlertManagerCounts(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get AlertManager instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertManagerTopology(options?: any): AxiosPromise<TopologyAlertManagerInfo> {
            return localVarFp.getAlertManagerTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Grafana instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrafanaTopology(options?: any): AxiosPromise<TopologyGrafanaInfo> {
            return localVarFp.getGrafanaTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all PD instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPDTopology(options?: any): AxiosPromise<Array<TopologyPDInfo>> {
            return localVarFp.getPDTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * List all profiling tasks with a given group ID
         * @summary List all tasks with a given group ID
         * @param {string} groupId group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroupDetail(groupId: string, options?: any): AxiosPromise<ProfilingGroupDetailResponse> {
            return localVarFp.getProfilingGroupDetail(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all profiling groups
         * @summary List all profiling groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingGroups(options?: any): AxiosPromise<Array<ProfilingTaskGroupModel>> {
            return localVarFp.getProfilingGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Scheduling instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulingTopology(options?: any): AxiosPromise<Array<TopologySchedulingInfo>> {
            return localVarFp.getSchedulingTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get location labels of all TiKV / TiFlash instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreLocationTopology(options?: any): AxiosPromise<TopologyStoreLocation> {
            return localVarFp.getStoreLocationTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all TiKV / TiFlash instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreTopology(options?: any): AxiosPromise<ClusterinfoStoreTopologyResponse> {
            return localVarFp.getStoreTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all TSO instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTSOTopology(options?: any): AxiosPromise<Array<TopologyTSOInfo>> {
            return localVarFp.getTSOTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all TiCDC instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiCDCTopology(options?: any): AxiosPromise<Array<TopologyTiCDCInfo>> {
            return localVarFp.getTiCDCTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all TiDB instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiDBTopology(options?: any): AxiosPromise<Array<TopologyTiDBInfo>> {
            return localVarFp.getTiDBTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all TiProxy instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiProxyTopology(options?: any): AxiosPromise<Array<TopologyTiProxyInfo>> {
            return localVarFp.getTiProxyTopology(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about this TiDB Dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoGet(options?: any): AxiosPromise<InfoInfoResponse> {
            return localVarFp.infoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all databases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoListDatabases(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.infoListDatabases(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tables by database name
         * @param {string} [databaseName] Database name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoListTables(databaseName?: string, options?: any): AxiosPromise<Array<InfoTableSchema>> {
            return localVarFp.infoListTables(databaseName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoWhoami(options?: any): AxiosPromise<InfoWhoAmIResponse> {
            return localVarFp.infoWhoami(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Key Visual Dynamic Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyvisualConfigGet(options?: any): AxiosPromise<ConfigKeyVisualConfig> {
            return localVarFp.keyvisualConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Key Visual Dynamic Config
         * @param {ConfigKeyVisualConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyvisualConfigPut(request: ConfigKeyVisualConfig, options?: any): AxiosPromise<ConfigKeyVisualConfig> {
            return localVarFp.keyvisualConfigPut(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Heatmaps in a given range to visualize TiKV usage
         * @summary Key Visual Heatmaps
         * @param {string} [startkey] The start of the key range
         * @param {string} [endkey] The end of the key range
         * @param {number} [starttime] The start of the time range (Unix)
         * @param {number} [endtime] The end of the time range (Unix)
         * @param {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'} [type] Main types of data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyvisualHeatmapsGet(startkey?: string, endkey?: string, starttime?: number, endtime?: number, type?: 'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration', options?: any): AxiosPromise<MatrixMatrix> {
            return localVarFp.keyvisualHeatmapsGet(startkey, endkey, starttime, endtime, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a download token for downloading logs
         * @param {Array<string>} [id] task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsDownloadAcquireTokenGet(id?: Array<string>, options?: any): AxiosPromise<string> {
            return localVarFp.logsDownloadAcquireTokenGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download logs
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsDownloadGet(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.logsDownloadGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create and run a new log search task group
         * @param {LogsearchCreateTaskGroupRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupPut(request: LogsearchCreateTaskGroupRequest, options?: any): AxiosPromise<LogsearchTaskGroupResponse> {
            return localVarFp.logsTaskgroupPut(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all log search task groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsGet(options?: any): AxiosPromise<Array<LogsearchTaskGroupModel>> {
            return localVarFp.logsTaskgroupsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel running tasks in a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdCancelPost(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.logsTaskgroupsIdCancelPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdDelete(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.logsTaskgroupsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tasks in a log search task group
         * @param {string} id Task Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdGet(id: string, options?: any): AxiosPromise<LogsearchTaskGroupResponse> {
            return localVarFp.logsTaskgroupsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Preview a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdPreviewGet(id: string, options?: any): AxiosPromise<Array<LogsearchPreviewModel>> {
            return localVarFp.logsTaskgroupsIdPreviewGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retry failed tasks in a log search task group
         * @param {string} id task group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsTaskgroupsIdRetryPost(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.logsTaskgroupsIdRetryPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Prometheus address cluster config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGetPromAddress(options?: any): AxiosPromise<MetricsGetPromAddressConfigResponse> {
            return localVarFp.metricsGetPromAddress(options).then((request) => request(axios, basePath));
        },
        /**
         * Query metrics in the given range
         * @summary Query metrics
         * @param {number} [endTimeSec] 
         * @param {string} [query] 
         * @param {number} [startTimeSec] 
         * @param {number} [stepSec] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsQueryGet(endTimeSec?: number, query?: string, startTimeSec?: number, stepSec?: number, options?: any): AxiosPromise<MetricsQueryResponse> {
            return localVarFp.metricsQueryGet(endTimeSec, query, startTimeSec, stepSec, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set or clear the customized Prometheus address
         * @param {MetricsPutCustomPromAddressRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsSetCustomPromAddress(request: MetricsPutCustomPromAddressRequest, options?: any): AxiosPromise<MetricsPutCustomPromAddressResponse> {
            return localVarFp.metricsSetCustomPromAddress(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Profiling Dynamic Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingConfigGet(options?: any): AxiosPromise<ConfigProfilingConfig> {
            return localVarFp.profilingConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Profiling Dynamic Config
         * @param {ConfigProfilingConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingConfigPut(request: ConfigProfilingConfig, options?: any): AxiosPromise<ConfigProfilingConfig> {
            return localVarFp.profilingConfigPut(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run statements
         * @param {QueryeditorRunRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryEditorRun(request: QueryeditorRunRequest, options?: any): AxiosPromise<QueryeditorRunResponse> {
            return localVarFp.queryEditorRun(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get calibrate of Resource Groups by actual workload
         * @param {number} [endTime] 
         * @param {number} [startTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceManagerCalibrateActualGet(endTime?: number, startTime?: number, options?: any): AxiosPromise<ResourcemanagerCalibrateResponse> {
            return localVarFp.resourceManagerCalibrateActualGet(endTime, startTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get calibrate of Resource Groups by hardware deployment
         * @param {string} workload workload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceManagerCalibrateHardwareGet(workload: string, options?: any): AxiosPromise<ResourcemanagerCalibrateResponse> {
            return localVarFp.resourceManagerCalibrateHardwareGet(workload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Resource Control enable config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceManagerConfigGet(options?: any): AxiosPromise<ResourcemanagerGetConfigResponse> {
            return localVarFp.resourceManagerConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Information of Resource Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceManagerInformationGet(options?: any): AxiosPromise<Array<ResourcemanagerResourceInfoRowDef>> {
            return localVarFp.resourceManagerInformationGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all resource groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceManagerInformationGroupNamesGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.resourceManagerInformationGroupNamesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get available field names by slowquery table columns
         * @summary Get available field names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryAvailableFieldsGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.slowQueryAvailableFieldsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a slow query
         * @param {string} [connectId] TODO: Switch back to uint64 when modern browser as well as Swagger handles BigInt well.
         * @param {string} [digest] 
         * @param {number} [timestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryDetailGet(connectId?: string, digest?: string, timestamp?: number, options?: any): AxiosPromise<SlowqueryModel> {
            return localVarFp.slowQueryDetailGet(connectId, digest, timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download slow query statements
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryDownloadGet(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.slowQueryDownloadGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a download token for exported slow query statements
         * @param {SlowqueryGetListRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryDownloadTokenPost(request: SlowqueryGetListRequest, options?: any): AxiosPromise<string> {
            return localVarFp.slowQueryDownloadTokenPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all slow queries
         * @param {number} [beginTime] 
         * @param {Array<string>} [db] 
         * @param {boolean} [desc] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {string} [fields] example: \&quot;Query,Digest\&quot;
         * @param {number} [limit] 
         * @param {string} [orderBy] 
         * @param {Array<string>} [plans] for showing slow queries in the statement detail page
         * @param {Array<string>} [resourceGroup] 
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowQueryListGet(beginTime?: number, db?: Array<string>, desc?: boolean, digest?: string, endTime?: number, fields?: string, limit?: number, orderBy?: string, plans?: Array<string>, resourceGroup?: Array<string>, text?: string, options?: any): AxiosPromise<Array<SlowqueryModel>> {
            return localVarFp.slowQueryListGet(beginTime, db, desc, digest, endTime, fields, limit, orderBy, plans, resourceGroup, text, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a profiling task group
         * @summary Start profiling
         * @param {ProfilingStartRequest} req profiling request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProfiling(req: ProfilingStartRequest, options?: any): AxiosPromise<ProfilingTaskGroupModel> {
            return localVarFp.startProfiling(req, options).then((request) => request(axios, basePath));
        },
        /**
         * Get available field names by statements table columns
         * @summary Get available field names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsAvailableFieldsGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.statementsAvailableFieldsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get statement configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsConfigGet(options?: any): AxiosPromise<StatementEditableConfig> {
            return localVarFp.statementsConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update statement configurations
         * @param {StatementEditableConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsConfigPost(request: StatementEditableConfig, options?: any): AxiosPromise<string> {
            return localVarFp.statementsConfigPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download statements
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsDownloadGet(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.statementsDownloadGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a download token for exported statements
         * @param {StatementGetStatementsRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsDownloadTokenPost(request: StatementGetStatementsRequest, options?: any): AxiosPromise<string> {
            return localVarFp.statementsDownloadTokenPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of statements
         * @param {number} [beginTime] 
         * @param {number} [endTime] 
         * @param {string} [fields] 
         * @param {Array<string>} [resourceGroups] 
         * @param {Array<string>} [schemas] 
         * @param {Array<string>} [stmtTypes] 
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsListGet(beginTime?: number, endTime?: number, fields?: string, resourceGroups?: Array<string>, schemas?: Array<string>, stmtTypes?: Array<string>, text?: string, options?: any): AxiosPromise<Array<StatementModel>> {
            return localVarFp.statementsListGet(beginTime, endTime, fields, resourceGroups, schemas, stmtTypes, text, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Drop all manually created bindings for a statement
         * @param {string} sqlDigest query template ID (a.k.a. sql digest)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsPlanBindingDelete(sqlDigest: string, options?: any): AxiosPromise<string> {
            return localVarFp.statementsPlanBindingDelete(sqlDigest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the bound plan digest (if exists) of a statement
         * @param {string} sqlDigest query template id
         * @param {number} beginTime begin time
         * @param {number} endTime end time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsPlanBindingGet(sqlDigest: string, beginTime: number, endTime: number, options?: any): AxiosPromise<StatementBinding> {
            return localVarFp.statementsPlanBindingGet(sqlDigest, beginTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a binding for a statement and a plan
         * @param {string} planDigest plan digest id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsPlanBindingPost(planDigest: string, options?: any): AxiosPromise<string> {
            return localVarFp.statementsPlanBindingPost(planDigest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a statement in an execution plan
         * @param {number} [beginTime] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {Array<string>} [plans] 
         * @param {string} [schemaName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsPlanDetailGet(beginTime?: number, digest?: string, endTime?: number, plans?: Array<string>, schemaName?: string, options?: any): AxiosPromise<StatementModel> {
            return localVarFp.statementsPlanDetailGet(beginTime, digest, endTime, plans, schemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get execution plans of a statement
         * @param {number} [beginTime] 
         * @param {string} [digest] 
         * @param {number} [endTime] 
         * @param {string} [schemaName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsPlansGet(beginTime?: number, digest?: string, endTime?: number, schemaName?: string, options?: any): AxiosPromise<Array<StatementModel>> {
            return localVarFp.statementsPlansGet(beginTime, digest, endTime, schemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all statement types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statementsStmtTypesGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.statementsStmtTypesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Hide a TiDB instance
         * @param {string} address ip:port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topologyTidbAddressDelete(address: string, options?: any): AxiosPromise<void> {
            return localVarFp.topologyTidbAddressDelete(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Top SQL config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlConfigGet(options?: any): AxiosPromise<TopsqlEditableConfig> {
            return localVarFp.topsqlConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Top SQL config
         * @param {TopsqlEditableConfig} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlConfigPost(request: TopsqlEditableConfig, options?: any): AxiosPromise<string> {
            return localVarFp.topsqlConfigPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get availiable instances
         * @param {string} [end] 
         * @param {string} [start] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlInstancesGet(end?: string, start?: string, options?: any): AxiosPromise<TopsqlInstanceResponse> {
            return localVarFp.topsqlInstancesGet(end, start, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get summaries
         * @param {string} [end] 
         * @param {string} [groupBy] 
         * @param {string} [instance] 
         * @param {string} [instanceType] 
         * @param {string} [start] 
         * @param {string} [top] 
         * @param {string} [window] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topsqlSummaryGet(end?: string, groupBy?: string, instance?: string, instanceType?: string, start?: string, top?: string, window?: string, options?: any): AxiosPromise<TopsqlSummaryResponse> {
            return localVarFp.topsqlSummaryGet(end, groupBy, instance, instanceType, start, top, window, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get log in information, like supported authenticate types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetLoginInfo(options?: any): AxiosPromise<UserGetLoginInfoResponse> {
            return localVarFp.userGetLoginInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get sign out info
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetSignOutInfo(redirectUrl?: string, options?: any): AxiosPromise<UserSignOutInfo> {
            return localVarFp.userGetSignOutInfo(redirectUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Log in
         * @param {UserAuthenticateForm} message Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin(message: UserAuthenticateForm, options?: any): AxiosPromise<UserTokenResponse> {
            return localVarFp.userLogin(message, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset encryption key to revoke all authorized codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRevokeSession(options?: any): AxiosPromise<void> {
            return localVarFp.userRevokeSession(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an impersonation
         * @param {SsoCreateImpersonationRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOCreateImpersonation(request: SsoCreateImpersonationRequest, options?: any): AxiosPromise<SsoSSOImpersonationModel> {
            return localVarFp.userSSOCreateImpersonation(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get SSO Auth URL
         * @param {string} [codeVerifier] 
         * @param {string} [redirectUrl] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOGetAuthURL(codeVerifier?: string, redirectUrl?: string, state?: string, options?: any): AxiosPromise<string> {
            return localVarFp.userSSOGetAuthURL(codeVerifier, redirectUrl, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get SSO config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOGetConfig(options?: any): AxiosPromise<ConfigSSOCoreConfig> {
            return localVarFp.userSSOGetConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all impersonations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOListImpersonations(options?: any): AxiosPromise<Array<SsoSSOImpersonationModel>> {
            return localVarFp.userSSOListImpersonations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set SSO config
         * @param {SsoSetConfigRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSSOSetConfig(request: SsoSetConfigRequest, options?: any): AxiosPromise<ConfigSSOCoreConfig> {
            return localVarFp.userSSOSetConfig(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Share current session and generate a sharing code
         * @param {CodeShareRequest} request Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareSession(request: CodeShareRequest, options?: any): AxiosPromise<CodeShareResponse> {
            return localVarFp.userShareSession(request, options).then((request) => request(axios, basePath));
        },
        /**
         * View the finished profiling result of a task
         * @summary View the result of a task
         * @param {string} token download token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewProfilingSingle(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.viewProfilingSingle(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelProfilingGroup operation in DefaultApi.
 * @export
 * @interface DefaultApiCancelProfilingGroupRequest
 */
export interface DefaultApiCancelProfilingGroupRequest {
    /**
     * group ID
     * @type {string}
     * @memberof DefaultApiCancelProfilingGroup
     */
    readonly groupId: string
}

/**
 * Request parameters for configurationEdit operation in DefaultApi.
 * @export
 * @interface DefaultApiConfigurationEditRequest
 */
export interface DefaultApiConfigurationEditRequest {
    /**
     * Request body
     * @type {ConfigurationEditRequest}
     * @memberof DefaultApiConfigurationEdit
     */
    readonly request: ConfigurationEditRequest
}

/**
 * Request parameters for continuousProfilingActionTokenGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContinuousProfilingActionTokenGetRequest
 */
export interface DefaultApiContinuousProfilingActionTokenGetRequest {
    /**
     * target query string
     * @type {string}
     * @memberof DefaultApiContinuousProfilingActionTokenGet
     */
    readonly q: string
}

/**
 * Request parameters for continuousProfilingConfigPost operation in DefaultApi.
 * @export
 * @interface DefaultApiContinuousProfilingConfigPostRequest
 */
export interface DefaultApiContinuousProfilingConfigPostRequest {
    /**
     * Request body
     * @type {ConprofNgMonitoringConfig}
     * @memberof DefaultApiContinuousProfilingConfigPost
     */
    readonly request: ConprofNgMonitoringConfig
}

/**
 * Request parameters for continuousProfilingDownloadGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContinuousProfilingDownloadGetRequest
 */
export interface DefaultApiContinuousProfilingDownloadGetRequest {
    /**
     * timestamp
     * @type {number}
     * @memberof DefaultApiContinuousProfilingDownloadGet
     */
    readonly ts: number
}

/**
 * Request parameters for continuousProfilingGroupProfileDetailGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContinuousProfilingGroupProfileDetailGetRequest
 */
export interface DefaultApiContinuousProfilingGroupProfileDetailGetRequest {
    /**
     * timestamp
     * @type {number}
     * @memberof DefaultApiContinuousProfilingGroupProfileDetailGet
     */
    readonly ts: number
}

/**
 * Request parameters for continuousProfilingGroupProfilesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContinuousProfilingGroupProfilesGetRequest
 */
export interface DefaultApiContinuousProfilingGroupProfilesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiContinuousProfilingGroupProfilesGet
     */
    readonly beginTime?: number

    /**
     * 
     * @type {number}
     * @memberof DefaultApiContinuousProfilingGroupProfilesGet
     */
    readonly endTime?: number
}

/**
 * Request parameters for continuousProfilingSingleProfileViewGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContinuousProfilingSingleProfileViewGetRequest
 */
export interface DefaultApiContinuousProfilingSingleProfileViewGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiContinuousProfilingSingleProfileViewGet
     */
    readonly address?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContinuousProfilingSingleProfileViewGet
     */
    readonly component?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContinuousProfilingSingleProfileViewGet
     */
    readonly profileType?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiContinuousProfilingSingleProfileViewGet
     */
    readonly ts?: number
}

/**
 * Request parameters for debugAPIRequestEndpoint operation in DefaultApi.
 * @export
 * @interface DefaultApiDebugAPIRequestEndpointRequest
 */
export interface DefaultApiDebugAPIRequestEndpointRequest {
    /**
     * request payload
     * @type {EndpointRequestPayload}
     * @memberof DefaultApiDebugAPIRequestEndpoint
     */
    readonly req: EndpointRequestPayload
}

/**
 * Request parameters for debugApiDownloadGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDebugApiDownloadGetRequest
 */
export interface DefaultApiDebugApiDownloadGetRequest {
    /**
     * download token
     * @type {string}
     * @memberof DefaultApiDebugApiDownloadGet
     */
    readonly token: string
}

/**
 * Request parameters for deleteProfilingGroup operation in DefaultApi.
 * @export
 * @interface DefaultApiDeleteProfilingGroupRequest
 */
export interface DefaultApiDeleteProfilingGroupRequest {
    /**
     * group ID
     * @type {string}
     * @memberof DefaultApiDeleteProfilingGroup
     */
    readonly groupId: string
}

/**
 * Request parameters for diagnoseDiagnosisPost operation in DefaultApi.
 * @export
 * @interface DefaultApiDiagnoseDiagnosisPostRequest
 */
export interface DefaultApiDiagnoseDiagnosisPostRequest {
    /**
     * Request body
     * @type {DiagnoseGenDiagnosisReportRequest}
     * @memberof DefaultApiDiagnoseDiagnosisPost
     */
    readonly request: DiagnoseGenDiagnosisReportRequest
}

/**
 * Request parameters for diagnoseGenerateMetricsRelationship operation in DefaultApi.
 * @export
 * @interface DefaultApiDiagnoseGenerateMetricsRelationshipRequest
 */
export interface DefaultApiDiagnoseGenerateMetricsRelationshipRequest {
    /**
     * Request body
     * @type {DiagnoseGenerateMetricsRelationRequest}
     * @memberof DefaultApiDiagnoseGenerateMetricsRelationship
     */
    readonly request: DiagnoseGenerateMetricsRelationRequest
}

/**
 * Request parameters for diagnoseMetricsRelationViewGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDiagnoseMetricsRelationViewGetRequest
 */
export interface DefaultApiDiagnoseMetricsRelationViewGetRequest {
    /**
     * token
     * @type {string}
     * @memberof DefaultApiDiagnoseMetricsRelationViewGet
     */
    readonly token: string
}

/**
 * Request parameters for diagnoseReportsIdDataJsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDiagnoseReportsIdDataJsGetRequest
 */
export interface DefaultApiDiagnoseReportsIdDataJsGetRequest {
    /**
     * report id
     * @type {string}
     * @memberof DefaultApiDiagnoseReportsIdDataJsGet
     */
    readonly id: string
}

/**
 * Request parameters for diagnoseReportsIdDetailGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDiagnoseReportsIdDetailGetRequest
 */
export interface DefaultApiDiagnoseReportsIdDetailGetRequest {
    /**
     * report id
     * @type {string}
     * @memberof DefaultApiDiagnoseReportsIdDetailGet
     */
    readonly id: string
}

/**
 * Request parameters for diagnoseReportsIdStatusGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDiagnoseReportsIdStatusGetRequest
 */
export interface DefaultApiDiagnoseReportsIdStatusGetRequest {
    /**
     * report id
     * @type {string}
     * @memberof DefaultApiDiagnoseReportsIdStatusGet
     */
    readonly id: string
}

/**
 * Request parameters for diagnoseReportsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiDiagnoseReportsPostRequest
 */
export interface DefaultApiDiagnoseReportsPostRequest {
    /**
     * Request body
     * @type {DiagnoseGenerateReportRequest}
     * @memberof DefaultApiDiagnoseReportsPost
     */
    readonly request: DiagnoseGenerateReportRequest
}

/**
 * Request parameters for downloadProfilingGroup operation in DefaultApi.
 * @export
 * @interface DefaultApiDownloadProfilingGroupRequest
 */
export interface DefaultApiDownloadProfilingGroupRequest {
    /**
     * download token
     * @type {string}
     * @memberof DefaultApiDownloadProfilingGroup
     */
    readonly token: string
}

/**
 * Request parameters for downloadProfilingSingle operation in DefaultApi.
 * @export
 * @interface DefaultApiDownloadProfilingSingleRequest
 */
export interface DefaultApiDownloadProfilingSingleRequest {
    /**
     * download token
     * @type {string}
     * @memberof DefaultApiDownloadProfilingSingle
     */
    readonly token: string
}

/**
 * Request parameters for getActionToken operation in DefaultApi.
 * @export
 * @interface DefaultApiGetActionTokenRequest
 */
export interface DefaultApiGetActionTokenRequest {
    /**
     * group or task ID
     * @type {string}
     * @memberof DefaultApiGetActionToken
     */
    readonly id?: string

    /**
     * action
     * @type {string}
     * @memberof DefaultApiGetActionToken
     */
    readonly action?: string
}

/**
 * Request parameters for getAlertManagerCounts operation in DefaultApi.
 * @export
 * @interface DefaultApiGetAlertManagerCountsRequest
 */
export interface DefaultApiGetAlertManagerCountsRequest {
    /**
     * ip:port
     * @type {string}
     * @memberof DefaultApiGetAlertManagerCounts
     */
    readonly address: string
}

/**
 * Request parameters for getProfilingGroupDetail operation in DefaultApi.
 * @export
 * @interface DefaultApiGetProfilingGroupDetailRequest
 */
export interface DefaultApiGetProfilingGroupDetailRequest {
    /**
     * group ID
     * @type {string}
     * @memberof DefaultApiGetProfilingGroupDetail
     */
    readonly groupId: string
}

/**
 * Request parameters for infoListTables operation in DefaultApi.
 * @export
 * @interface DefaultApiInfoListTablesRequest
 */
export interface DefaultApiInfoListTablesRequest {
    /**
     * Database name
     * @type {string}
     * @memberof DefaultApiInfoListTables
     */
    readonly databaseName?: string
}

/**
 * Request parameters for keyvisualConfigPut operation in DefaultApi.
 * @export
 * @interface DefaultApiKeyvisualConfigPutRequest
 */
export interface DefaultApiKeyvisualConfigPutRequest {
    /**
     * Request body
     * @type {ConfigKeyVisualConfig}
     * @memberof DefaultApiKeyvisualConfigPut
     */
    readonly request: ConfigKeyVisualConfig
}

/**
 * Request parameters for keyvisualHeatmapsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiKeyvisualHeatmapsGetRequest
 */
export interface DefaultApiKeyvisualHeatmapsGetRequest {
    /**
     * The start of the key range
     * @type {string}
     * @memberof DefaultApiKeyvisualHeatmapsGet
     */
    readonly startkey?: string

    /**
     * The end of the key range
     * @type {string}
     * @memberof DefaultApiKeyvisualHeatmapsGet
     */
    readonly endkey?: string

    /**
     * The start of the time range (Unix)
     * @type {number}
     * @memberof DefaultApiKeyvisualHeatmapsGet
     */
    readonly starttime?: number

    /**
     * The end of the time range (Unix)
     * @type {number}
     * @memberof DefaultApiKeyvisualHeatmapsGet
     */
    readonly endtime?: number

    /**
     * Main types of data
     * @type {'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'}
     * @memberof DefaultApiKeyvisualHeatmapsGet
     */
    readonly type?: 'written_bytes' | 'read_bytes' | 'written_keys' | 'read_keys' | 'integration'
}

/**
 * Request parameters for logsDownloadAcquireTokenGet operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsDownloadAcquireTokenGetRequest
 */
export interface DefaultApiLogsDownloadAcquireTokenGetRequest {
    /**
     * task id
     * @type {Array<string>}
     * @memberof DefaultApiLogsDownloadAcquireTokenGet
     */
    readonly id?: Array<string>
}

/**
 * Request parameters for logsDownloadGet operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsDownloadGetRequest
 */
export interface DefaultApiLogsDownloadGetRequest {
    /**
     * download token
     * @type {string}
     * @memberof DefaultApiLogsDownloadGet
     */
    readonly token: string
}

/**
 * Request parameters for logsTaskgroupPut operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsTaskgroupPutRequest
 */
export interface DefaultApiLogsTaskgroupPutRequest {
    /**
     * Request body
     * @type {LogsearchCreateTaskGroupRequest}
     * @memberof DefaultApiLogsTaskgroupPut
     */
    readonly request: LogsearchCreateTaskGroupRequest
}

/**
 * Request parameters for logsTaskgroupsIdCancelPost operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsTaskgroupsIdCancelPostRequest
 */
export interface DefaultApiLogsTaskgroupsIdCancelPostRequest {
    /**
     * task group id
     * @type {string}
     * @memberof DefaultApiLogsTaskgroupsIdCancelPost
     */
    readonly id: string
}

/**
 * Request parameters for logsTaskgroupsIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsTaskgroupsIdDeleteRequest
 */
export interface DefaultApiLogsTaskgroupsIdDeleteRequest {
    /**
     * task group id
     * @type {string}
     * @memberof DefaultApiLogsTaskgroupsIdDelete
     */
    readonly id: string
}

/**
 * Request parameters for logsTaskgroupsIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsTaskgroupsIdGetRequest
 */
export interface DefaultApiLogsTaskgroupsIdGetRequest {
    /**
     * Task Group ID
     * @type {string}
     * @memberof DefaultApiLogsTaskgroupsIdGet
     */
    readonly id: string
}

/**
 * Request parameters for logsTaskgroupsIdPreviewGet operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsTaskgroupsIdPreviewGetRequest
 */
export interface DefaultApiLogsTaskgroupsIdPreviewGetRequest {
    /**
     * task group id
     * @type {string}
     * @memberof DefaultApiLogsTaskgroupsIdPreviewGet
     */
    readonly id: string
}

/**
 * Request parameters for logsTaskgroupsIdRetryPost operation in DefaultApi.
 * @export
 * @interface DefaultApiLogsTaskgroupsIdRetryPostRequest
 */
export interface DefaultApiLogsTaskgroupsIdRetryPostRequest {
    /**
     * task group id
     * @type {string}
     * @memberof DefaultApiLogsTaskgroupsIdRetryPost
     */
    readonly id: string
}

/**
 * Request parameters for metricsQueryGet operation in DefaultApi.
 * @export
 * @interface DefaultApiMetricsQueryGetRequest
 */
export interface DefaultApiMetricsQueryGetRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiMetricsQueryGet
     */
    readonly endTimeSec?: number

    /**
     * 
     * @type {string}
     * @memberof DefaultApiMetricsQueryGet
     */
    readonly query?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiMetricsQueryGet
     */
    readonly startTimeSec?: number

    /**
     * 
     * @type {number}
     * @memberof DefaultApiMetricsQueryGet
     */
    readonly stepSec?: number
}

/**
 * Request parameters for metricsSetCustomPromAddress operation in DefaultApi.
 * @export
 * @interface DefaultApiMetricsSetCustomPromAddressRequest
 */
export interface DefaultApiMetricsSetCustomPromAddressRequest {
    /**
     * Request body
     * @type {MetricsPutCustomPromAddressRequest}
     * @memberof DefaultApiMetricsSetCustomPromAddress
     */
    readonly request: MetricsPutCustomPromAddressRequest
}

/**
 * Request parameters for profilingConfigPut operation in DefaultApi.
 * @export
 * @interface DefaultApiProfilingConfigPutRequest
 */
export interface DefaultApiProfilingConfigPutRequest {
    /**
     * Request body
     * @type {ConfigProfilingConfig}
     * @memberof DefaultApiProfilingConfigPut
     */
    readonly request: ConfigProfilingConfig
}

/**
 * Request parameters for queryEditorRun operation in DefaultApi.
 * @export
 * @interface DefaultApiQueryEditorRunRequest
 */
export interface DefaultApiQueryEditorRunRequest {
    /**
     * Request body
     * @type {QueryeditorRunRequest}
     * @memberof DefaultApiQueryEditorRun
     */
    readonly request: QueryeditorRunRequest
}

/**
 * Request parameters for resourceManagerCalibrateActualGet operation in DefaultApi.
 * @export
 * @interface DefaultApiResourceManagerCalibrateActualGetRequest
 */
export interface DefaultApiResourceManagerCalibrateActualGetRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiResourceManagerCalibrateActualGet
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof DefaultApiResourceManagerCalibrateActualGet
     */
    readonly startTime?: number
}

/**
 * Request parameters for resourceManagerCalibrateHardwareGet operation in DefaultApi.
 * @export
 * @interface DefaultApiResourceManagerCalibrateHardwareGetRequest
 */
export interface DefaultApiResourceManagerCalibrateHardwareGetRequest {
    /**
     * workload
     * @type {string}
     * @memberof DefaultApiResourceManagerCalibrateHardwareGet
     */
    readonly workload: string
}

/**
 * Request parameters for slowQueryDetailGet operation in DefaultApi.
 * @export
 * @interface DefaultApiSlowQueryDetailGetRequest
 */
export interface DefaultApiSlowQueryDetailGetRequest {
    /**
     * TODO: Switch back to uint64 when modern browser as well as Swagger handles BigInt well.
     * @type {string}
     * @memberof DefaultApiSlowQueryDetailGet
     */
    readonly connectId?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSlowQueryDetailGet
     */
    readonly digest?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiSlowQueryDetailGet
     */
    readonly timestamp?: number
}

/**
 * Request parameters for slowQueryDownloadGet operation in DefaultApi.
 * @export
 * @interface DefaultApiSlowQueryDownloadGetRequest
 */
export interface DefaultApiSlowQueryDownloadGetRequest {
    /**
     * download token
     * @type {string}
     * @memberof DefaultApiSlowQueryDownloadGet
     */
    readonly token: string
}

/**
 * Request parameters for slowQueryDownloadTokenPost operation in DefaultApi.
 * @export
 * @interface DefaultApiSlowQueryDownloadTokenPostRequest
 */
export interface DefaultApiSlowQueryDownloadTokenPostRequest {
    /**
     * Request body
     * @type {SlowqueryGetListRequest}
     * @memberof DefaultApiSlowQueryDownloadTokenPost
     */
    readonly request: SlowqueryGetListRequest
}

/**
 * Request parameters for slowQueryListGet operation in DefaultApi.
 * @export
 * @interface DefaultApiSlowQueryListGetRequest
 */
export interface DefaultApiSlowQueryListGetRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly beginTime?: number

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly db?: Array<string>

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly desc?: boolean

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly digest?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly endTime?: number

    /**
     * example: \&quot;Query,Digest\&quot;
     * @type {string}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly fields?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly orderBy?: string

    /**
     * for showing slow queries in the statement detail page
     * @type {Array<string>}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly plans?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly resourceGroup?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSlowQueryListGet
     */
    readonly text?: string
}

/**
 * Request parameters for startProfiling operation in DefaultApi.
 * @export
 * @interface DefaultApiStartProfilingRequest
 */
export interface DefaultApiStartProfilingRequest {
    /**
     * profiling request
     * @type {ProfilingStartRequest}
     * @memberof DefaultApiStartProfiling
     */
    readonly req: ProfilingStartRequest
}

/**
 * Request parameters for statementsConfigPost operation in DefaultApi.
 * @export
 * @interface DefaultApiStatementsConfigPostRequest
 */
export interface DefaultApiStatementsConfigPostRequest {
    /**
     * Request body
     * @type {StatementEditableConfig}
     * @memberof DefaultApiStatementsConfigPost
     */
    readonly request: StatementEditableConfig
}

/**
 * Request parameters for statementsDownloadGet operation in DefaultApi.
 * @export
 * @interface DefaultApiStatementsDownloadGetRequest
 */
export interface DefaultApiStatementsDownloadGetRequest {
    /**
     * download token
     * @type {string}
     * @memberof DefaultApiStatementsDownloadGet
     */
    readonly token: string
}

/**
 * Request parameters for statementsDownloadTokenPost operation in DefaultApi.
 * @export
 * @interface DefaultApiStatementsDownloadTokenPostRequest
 */
export interface DefaultApiStatementsDownloadTokenPostRequest {
    /**
     * Request body
     * @type {StatementGetStatementsRequest}
     * @memberof DefaultApiStatementsDownloadTokenPost
     */
    readonly request: StatementGetStatementsRequest
}

/**
 * Request parameters for statementsListGet operation in DefaultApi.
 * @export
 * @interface DefaultApiStatementsListGetRequest
 */
export interface DefaultApiStatementsListGetRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiStatementsListGet
     */
    readonly beginTime?: number

    /**
     * 
     * @type {number}
     * @memberof DefaultApiStatementsListGet
     */
    readonly endTime?: number

    /**
     * 
     * @type {string}
     * @memberof DefaultApiStatementsListGet
     */
    readonly fields?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiStatementsListGet
     */
    readonly resourceGroups?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiStatementsListGet
     */
    readonly schemas?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiStatementsListGet
     */
    readonly stmtTypes?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof DefaultApiStatementsListGet
     */
    readonly text?: string
}

/**
 * Request parameters for statementsPlanBindingDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiStatementsPlanBindingDeleteRequest
 */
export interface DefaultApiStatementsPlanBindingDeleteRequest {
    /**
     * query template ID (a.k.a. sql digest)
     * @type {string}
     * @memberof DefaultApiStatementsPlanBindingDelete
     */
    readonly sqlDigest: string
}

/**
 * Request parameters for statementsPlanBindingGet operation in DefaultApi.
 * @export
 * @interface DefaultApiStatementsPlanBindingGetRequest
 */
export interface DefaultApiStatementsPlanBindingGetRequest {
    /**
     * query template id
     * @type {string}
     * @memberof DefaultApiStatementsPlanBindingGet
     */
    readonly sqlDigest: string

    /**
     * begin time
     * @type {number}
     * @memberof DefaultApiStatementsPlanBindingGet
     */
    readonly beginTime: number

    /**
     * end time
     * @type {number}
     * @memberof DefaultApiStatementsPlanBindingGet
     */
    readonly endTime: number
}

/**
 * Request parameters for statementsPlanBindingPost operation in DefaultApi.
 * @export
 * @interface DefaultApiStatementsPlanBindingPostRequest
 */
export interface DefaultApiStatementsPlanBindingPostRequest {
    /**
     * plan digest id
     * @type {string}
     * @memberof DefaultApiStatementsPlanBindingPost
     */
    readonly planDigest: string
}

/**
 * Request parameters for statementsPlanDetailGet operation in DefaultApi.
 * @export
 * @interface DefaultApiStatementsPlanDetailGetRequest
 */
export interface DefaultApiStatementsPlanDetailGetRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiStatementsPlanDetailGet
     */
    readonly beginTime?: number

    /**
     * 
     * @type {string}
     * @memberof DefaultApiStatementsPlanDetailGet
     */
    readonly digest?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiStatementsPlanDetailGet
     */
    readonly endTime?: number

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiStatementsPlanDetailGet
     */
    readonly plans?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof DefaultApiStatementsPlanDetailGet
     */
    readonly schemaName?: string
}

/**
 * Request parameters for statementsPlansGet operation in DefaultApi.
 * @export
 * @interface DefaultApiStatementsPlansGetRequest
 */
export interface DefaultApiStatementsPlansGetRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiStatementsPlansGet
     */
    readonly beginTime?: number

    /**
     * 
     * @type {string}
     * @memberof DefaultApiStatementsPlansGet
     */
    readonly digest?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiStatementsPlansGet
     */
    readonly endTime?: number

    /**
     * 
     * @type {string}
     * @memberof DefaultApiStatementsPlansGet
     */
    readonly schemaName?: string
}

/**
 * Request parameters for topologyTidbAddressDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiTopologyTidbAddressDeleteRequest
 */
export interface DefaultApiTopologyTidbAddressDeleteRequest {
    /**
     * ip:port
     * @type {string}
     * @memberof DefaultApiTopologyTidbAddressDelete
     */
    readonly address: string
}

/**
 * Request parameters for topsqlConfigPost operation in DefaultApi.
 * @export
 * @interface DefaultApiTopsqlConfigPostRequest
 */
export interface DefaultApiTopsqlConfigPostRequest {
    /**
     * Request body
     * @type {TopsqlEditableConfig}
     * @memberof DefaultApiTopsqlConfigPost
     */
    readonly request: TopsqlEditableConfig
}

/**
 * Request parameters for topsqlInstancesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiTopsqlInstancesGetRequest
 */
export interface DefaultApiTopsqlInstancesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlInstancesGet
     */
    readonly end?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlInstancesGet
     */
    readonly start?: string
}

/**
 * Request parameters for topsqlSummaryGet operation in DefaultApi.
 * @export
 * @interface DefaultApiTopsqlSummaryGetRequest
 */
export interface DefaultApiTopsqlSummaryGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlSummaryGet
     */
    readonly end?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlSummaryGet
     */
    readonly groupBy?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlSummaryGet
     */
    readonly instance?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlSummaryGet
     */
    readonly instanceType?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlSummaryGet
     */
    readonly start?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlSummaryGet
     */
    readonly top?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiTopsqlSummaryGet
     */
    readonly window?: string
}

/**
 * Request parameters for userGetSignOutInfo operation in DefaultApi.
 * @export
 * @interface DefaultApiUserGetSignOutInfoRequest
 */
export interface DefaultApiUserGetSignOutInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiUserGetSignOutInfo
     */
    readonly redirectUrl?: string
}

/**
 * Request parameters for userLogin operation in DefaultApi.
 * @export
 * @interface DefaultApiUserLoginRequest
 */
export interface DefaultApiUserLoginRequest {
    /**
     * Credentials
     * @type {UserAuthenticateForm}
     * @memberof DefaultApiUserLogin
     */
    readonly message: UserAuthenticateForm
}

/**
 * Request parameters for userSSOCreateImpersonation operation in DefaultApi.
 * @export
 * @interface DefaultApiUserSSOCreateImpersonationRequest
 */
export interface DefaultApiUserSSOCreateImpersonationRequest {
    /**
     * Request body
     * @type {SsoCreateImpersonationRequest}
     * @memberof DefaultApiUserSSOCreateImpersonation
     */
    readonly request: SsoCreateImpersonationRequest
}

/**
 * Request parameters for userSSOGetAuthURL operation in DefaultApi.
 * @export
 * @interface DefaultApiUserSSOGetAuthURLRequest
 */
export interface DefaultApiUserSSOGetAuthURLRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiUserSSOGetAuthURL
     */
    readonly codeVerifier?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiUserSSOGetAuthURL
     */
    readonly redirectUrl?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiUserSSOGetAuthURL
     */
    readonly state?: string
}

/**
 * Request parameters for userSSOSetConfig operation in DefaultApi.
 * @export
 * @interface DefaultApiUserSSOSetConfigRequest
 */
export interface DefaultApiUserSSOSetConfigRequest {
    /**
     * Request body
     * @type {SsoSetConfigRequest}
     * @memberof DefaultApiUserSSOSetConfig
     */
    readonly request: SsoSetConfigRequest
}

/**
 * Request parameters for userShareSession operation in DefaultApi.
 * @export
 * @interface DefaultApiUserShareSessionRequest
 */
export interface DefaultApiUserShareSessionRequest {
    /**
     * Request body
     * @type {CodeShareRequest}
     * @memberof DefaultApiUserShareSession
     */
    readonly request: CodeShareRequest
}

/**
 * Request parameters for viewProfilingSingle operation in DefaultApi.
 * @export
 * @interface DefaultApiViewProfilingSingleRequest
 */
export interface DefaultApiViewProfilingSingleRequest {
    /**
     * download token
     * @type {string}
     * @memberof DefaultApiViewProfilingSingle
     */
    readonly token: string
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Cancel all profling tasks with a given group ID
     * @summary Cancel all tasks with a given group ID
     * @param {DefaultApiCancelProfilingGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelProfilingGroup(requestParameters: DefaultApiCancelProfilingGroupRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cancelProfilingGroup(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information of all hosts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public clusterInfoGetHostsInfo(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).clusterInfoGetHostsInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public clusterInfoGetStatistics(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).clusterInfoGetStatistics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a configuration
     * @param {DefaultApiConfigurationEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public configurationEdit(requestParameters: DefaultApiConfigurationEditRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).configurationEdit(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all configurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public configurationGetAll(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).configurationGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get action token for download or view profile
     * @param {DefaultApiContinuousProfilingActionTokenGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingActionTokenGet(requestParameters: DefaultApiContinuousProfilingActionTokenGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingActionTokenGet(requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current scraping components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingComponentsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingComponentsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Continuous Profiling Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingConfigGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Continuous Profiling Config
     * @param {DefaultApiContinuousProfilingConfigPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingConfigPost(requestParameters: DefaultApiContinuousProfilingConfigPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingConfigPost(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Group Profile files
     * @param {DefaultApiContinuousProfilingDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingDownloadGet(requestParameters: DefaultApiContinuousProfilingDownloadGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingDownloadGet(requestParameters.ts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Estimate Size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingEstimateSizeGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingEstimateSizeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Group Profile Detail
     * @param {DefaultApiContinuousProfilingGroupProfileDetailGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingGroupProfileDetailGet(requestParameters: DefaultApiContinuousProfilingGroupProfileDetailGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingGroupProfileDetailGet(requestParameters.ts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Group Profiles
     * @param {DefaultApiContinuousProfilingGroupProfilesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingGroupProfilesGet(requestParameters: DefaultApiContinuousProfilingGroupProfilesGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingGroupProfilesGet(requestParameters.beginTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View Single Profile files
     * @param {DefaultApiContinuousProfilingSingleProfileViewGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continuousProfilingSingleProfileViewGet(requestParameters: DefaultApiContinuousProfilingSingleProfileViewGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continuousProfilingSingleProfileViewGet(requestParameters.address, requestParameters.component, requestParameters.profileType, requestParameters.ts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all deadlock records
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deadlockListGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deadlockListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all endpoints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public debugAPIGetEndpoints(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).debugAPIGetEndpoints(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send request remote endpoint and return a token for downloading results
     * @param {DefaultApiDebugAPIRequestEndpointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public debugAPIRequestEndpoint(requestParameters: DefaultApiDebugAPIRequestEndpointRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).debugAPIRequestEndpoint(requestParameters.req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a finished request result
     * @param {DefaultApiDebugApiDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public debugApiDownloadGet(requestParameters: DefaultApiDebugApiDownloadGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).debugApiDownloadGet(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all finished profiling tasks with a given group ID
     * @summary Delete all tasks with a given group ID
     * @param {DefaultApiDeleteProfilingGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteProfilingGroup(requestParameters: DefaultApiDeleteProfilingGroupRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteProfilingGroup(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate sql diagnosis report
     * @summary SQL diagnosis report
     * @param {DefaultApiDiagnoseDiagnosisPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseDiagnosisPost(requestParameters: DefaultApiDiagnoseDiagnosisPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseDiagnosisPost(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate metrics relationship graph.
     * @param {DefaultApiDiagnoseGenerateMetricsRelationshipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseGenerateMetricsRelationship(requestParameters: DefaultApiDiagnoseGenerateMetricsRelationshipRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseGenerateMetricsRelationship(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View metrics relationship graph.
     * @param {DefaultApiDiagnoseMetricsRelationViewGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseMetricsRelationViewGet(requestParameters: DefaultApiDiagnoseMetricsRelationViewGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseMetricsRelationViewGet(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get sql diagnosis reports history
     * @summary SQL diagnosis reports history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseReportsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseReportsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get sql diagnosis report data
     * @summary SQL diagnosis report data
     * @param {DefaultApiDiagnoseReportsIdDataJsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseReportsIdDataJsGet(requestParameters: DefaultApiDiagnoseReportsIdDataJsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseReportsIdDataJsGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get sql diagnosis report HTML
     * @summary SQL diagnosis report
     * @param {DefaultApiDiagnoseReportsIdDetailGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseReportsIdDetailGet(requestParameters: DefaultApiDiagnoseReportsIdDetailGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseReportsIdDetailGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get diagnosis report status
     * @summary Diagnosis report status
     * @param {DefaultApiDiagnoseReportsIdStatusGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseReportsIdStatusGet(requestParameters: DefaultApiDiagnoseReportsIdStatusGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseReportsIdStatusGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate sql diagnosis report
     * @summary SQL diagnosis report
     * @param {DefaultApiDiagnoseReportsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseReportsPost(requestParameters: DefaultApiDiagnoseReportsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseReportsPost(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download all finished profiling results of a task group
     * @summary Download all results of a task group
     * @param {DefaultApiDownloadProfilingGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadProfilingGroup(requestParameters: DefaultApiDownloadProfilingGroupRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadProfilingGroup(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download the finished profiling result of a task
     * @summary Download the result of a task
     * @param {DefaultApiDownloadProfilingSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadProfilingSingle(requestParameters: DefaultApiDownloadProfilingSingleRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadProfilingSingle(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get token with a given group ID or task ID and action type
     * @summary Get action token for download or view
     * @param {DefaultApiGetActionTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getActionToken(requestParameters: DefaultApiGetActionTokenRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getActionToken(requestParameters.id, requestParameters.action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current alert count from AlertManager
     * @param {DefaultApiGetAlertManagerCountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAlertManagerCounts(requestParameters: DefaultApiGetAlertManagerCountsRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAlertManagerCounts(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get AlertManager instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAlertManagerTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAlertManagerTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Grafana instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGrafanaTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGrafanaTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all PD instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPDTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPDTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all profiling tasks with a given group ID
     * @summary List all tasks with a given group ID
     * @param {DefaultApiGetProfilingGroupDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProfilingGroupDetail(requestParameters: DefaultApiGetProfilingGroupDetailRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProfilingGroupDetail(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all profiling groups
     * @summary List all profiling groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProfilingGroups(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProfilingGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Scheduling instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSchedulingTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSchedulingTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get location labels of all TiKV / TiFlash instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStoreLocationTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStoreLocationTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all TiKV / TiFlash instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStoreTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStoreTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all TSO instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTSOTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTSOTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all TiCDC instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTiCDCTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTiCDCTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all TiDB instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTiDBTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTiDBTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all TiProxy instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTiProxyTopology(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTiProxyTopology(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about this TiDB Dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public infoGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).infoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all databases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public infoListDatabases(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).infoListDatabases(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tables by database name
     * @param {DefaultApiInfoListTablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public infoListTables(requestParameters: DefaultApiInfoListTablesRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).infoListTables(requestParameters.databaseName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public infoWhoami(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).infoWhoami(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Key Visual Dynamic Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public keyvisualConfigGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).keyvisualConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Key Visual Dynamic Config
     * @param {DefaultApiKeyvisualConfigPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public keyvisualConfigPut(requestParameters: DefaultApiKeyvisualConfigPutRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).keyvisualConfigPut(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Heatmaps in a given range to visualize TiKV usage
     * @summary Key Visual Heatmaps
     * @param {DefaultApiKeyvisualHeatmapsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public keyvisualHeatmapsGet(requestParameters: DefaultApiKeyvisualHeatmapsGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).keyvisualHeatmapsGet(requestParameters.startkey, requestParameters.endkey, requestParameters.starttime, requestParameters.endtime, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a download token for downloading logs
     * @param {DefaultApiLogsDownloadAcquireTokenGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsDownloadAcquireTokenGet(requestParameters: DefaultApiLogsDownloadAcquireTokenGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsDownloadAcquireTokenGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download logs
     * @param {DefaultApiLogsDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsDownloadGet(requestParameters: DefaultApiLogsDownloadGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsDownloadGet(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create and run a new log search task group
     * @param {DefaultApiLogsTaskgroupPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupPut(requestParameters: DefaultApiLogsTaskgroupPutRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsTaskgroupPut(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all log search task groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsTaskgroupsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel running tasks in a log search task group
     * @param {DefaultApiLogsTaskgroupsIdCancelPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsIdCancelPost(requestParameters: DefaultApiLogsTaskgroupsIdCancelPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsTaskgroupsIdCancelPost(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a log search task group
     * @param {DefaultApiLogsTaskgroupsIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsIdDelete(requestParameters: DefaultApiLogsTaskgroupsIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsTaskgroupsIdDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tasks in a log search task group
     * @param {DefaultApiLogsTaskgroupsIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsIdGet(requestParameters: DefaultApiLogsTaskgroupsIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsTaskgroupsIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Preview a log search task group
     * @param {DefaultApiLogsTaskgroupsIdPreviewGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsIdPreviewGet(requestParameters: DefaultApiLogsTaskgroupsIdPreviewGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsTaskgroupsIdPreviewGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retry failed tasks in a log search task group
     * @param {DefaultApiLogsTaskgroupsIdRetryPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logsTaskgroupsIdRetryPost(requestParameters: DefaultApiLogsTaskgroupsIdRetryPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logsTaskgroupsIdRetryPost(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Prometheus address cluster config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public metricsGetPromAddress(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).metricsGetPromAddress(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query metrics in the given range
     * @summary Query metrics
     * @param {DefaultApiMetricsQueryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public metricsQueryGet(requestParameters: DefaultApiMetricsQueryGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).metricsQueryGet(requestParameters.endTimeSec, requestParameters.query, requestParameters.startTimeSec, requestParameters.stepSec, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set or clear the customized Prometheus address
     * @param {DefaultApiMetricsSetCustomPromAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public metricsSetCustomPromAddress(requestParameters: DefaultApiMetricsSetCustomPromAddressRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).metricsSetCustomPromAddress(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Profiling Dynamic Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilingConfigGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilingConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Profiling Dynamic Config
     * @param {DefaultApiProfilingConfigPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilingConfigPut(requestParameters: DefaultApiProfilingConfigPutRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilingConfigPut(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run statements
     * @param {DefaultApiQueryEditorRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public queryEditorRun(requestParameters: DefaultApiQueryEditorRunRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).queryEditorRun(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get calibrate of Resource Groups by actual workload
     * @param {DefaultApiResourceManagerCalibrateActualGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resourceManagerCalibrateActualGet(requestParameters: DefaultApiResourceManagerCalibrateActualGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resourceManagerCalibrateActualGet(requestParameters.endTime, requestParameters.startTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get calibrate of Resource Groups by hardware deployment
     * @param {DefaultApiResourceManagerCalibrateHardwareGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resourceManagerCalibrateHardwareGet(requestParameters: DefaultApiResourceManagerCalibrateHardwareGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resourceManagerCalibrateHardwareGet(requestParameters.workload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Resource Control enable config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resourceManagerConfigGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resourceManagerConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Information of Resource Groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resourceManagerInformationGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resourceManagerInformationGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all resource groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resourceManagerInformationGroupNamesGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resourceManagerInformationGroupNamesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get available field names by slowquery table columns
     * @summary Get available field names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public slowQueryAvailableFieldsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).slowQueryAvailableFieldsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a slow query
     * @param {DefaultApiSlowQueryDetailGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public slowQueryDetailGet(requestParameters: DefaultApiSlowQueryDetailGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).slowQueryDetailGet(requestParameters.connectId, requestParameters.digest, requestParameters.timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download slow query statements
     * @param {DefaultApiSlowQueryDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public slowQueryDownloadGet(requestParameters: DefaultApiSlowQueryDownloadGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).slowQueryDownloadGet(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a download token for exported slow query statements
     * @param {DefaultApiSlowQueryDownloadTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public slowQueryDownloadTokenPost(requestParameters: DefaultApiSlowQueryDownloadTokenPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).slowQueryDownloadTokenPost(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all slow queries
     * @param {DefaultApiSlowQueryListGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public slowQueryListGet(requestParameters: DefaultApiSlowQueryListGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).slowQueryListGet(requestParameters.beginTime, requestParameters.db, requestParameters.desc, requestParameters.digest, requestParameters.endTime, requestParameters.fields, requestParameters.limit, requestParameters.orderBy, requestParameters.plans, requestParameters.resourceGroup, requestParameters.text, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a profiling task group
     * @summary Start profiling
     * @param {DefaultApiStartProfilingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public startProfiling(requestParameters: DefaultApiStartProfilingRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).startProfiling(requestParameters.req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get available field names by statements table columns
     * @summary Get available field names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsAvailableFieldsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsAvailableFieldsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get statement configurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsConfigGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update statement configurations
     * @param {DefaultApiStatementsConfigPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsConfigPost(requestParameters: DefaultApiStatementsConfigPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsConfigPost(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download statements
     * @param {DefaultApiStatementsDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsDownloadGet(requestParameters: DefaultApiStatementsDownloadGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsDownloadGet(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a download token for exported statements
     * @param {DefaultApiStatementsDownloadTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsDownloadTokenPost(requestParameters: DefaultApiStatementsDownloadTokenPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsDownloadTokenPost(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of statements
     * @param {DefaultApiStatementsListGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsListGet(requestParameters: DefaultApiStatementsListGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsListGet(requestParameters.beginTime, requestParameters.endTime, requestParameters.fields, requestParameters.resourceGroups, requestParameters.schemas, requestParameters.stmtTypes, requestParameters.text, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Drop all manually created bindings for a statement
     * @param {DefaultApiStatementsPlanBindingDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsPlanBindingDelete(requestParameters: DefaultApiStatementsPlanBindingDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsPlanBindingDelete(requestParameters.sqlDigest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the bound plan digest (if exists) of a statement
     * @param {DefaultApiStatementsPlanBindingGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsPlanBindingGet(requestParameters: DefaultApiStatementsPlanBindingGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsPlanBindingGet(requestParameters.sqlDigest, requestParameters.beginTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a binding for a statement and a plan
     * @param {DefaultApiStatementsPlanBindingPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsPlanBindingPost(requestParameters: DefaultApiStatementsPlanBindingPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsPlanBindingPost(requestParameters.planDigest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a statement in an execution plan
     * @param {DefaultApiStatementsPlanDetailGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsPlanDetailGet(requestParameters: DefaultApiStatementsPlanDetailGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsPlanDetailGet(requestParameters.beginTime, requestParameters.digest, requestParameters.endTime, requestParameters.plans, requestParameters.schemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get execution plans of a statement
     * @param {DefaultApiStatementsPlansGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsPlansGet(requestParameters: DefaultApiStatementsPlansGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsPlansGet(requestParameters.beginTime, requestParameters.digest, requestParameters.endTime, requestParameters.schemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all statement types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statementsStmtTypesGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statementsStmtTypesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Hide a TiDB instance
     * @param {DefaultApiTopologyTidbAddressDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public topologyTidbAddressDelete(requestParameters: DefaultApiTopologyTidbAddressDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).topologyTidbAddressDelete(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Top SQL config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public topsqlConfigGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).topsqlConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Top SQL config
     * @param {DefaultApiTopsqlConfigPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public topsqlConfigPost(requestParameters: DefaultApiTopsqlConfigPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).topsqlConfigPost(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get availiable instances
     * @param {DefaultApiTopsqlInstancesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public topsqlInstancesGet(requestParameters: DefaultApiTopsqlInstancesGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).topsqlInstancesGet(requestParameters.end, requestParameters.start, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get summaries
     * @param {DefaultApiTopsqlSummaryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public topsqlSummaryGet(requestParameters: DefaultApiTopsqlSummaryGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).topsqlSummaryGet(requestParameters.end, requestParameters.groupBy, requestParameters.instance, requestParameters.instanceType, requestParameters.start, requestParameters.top, requestParameters.window, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get log in information, like supported authenticate types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userGetLoginInfo(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userGetLoginInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get sign out info
     * @param {DefaultApiUserGetSignOutInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userGetSignOutInfo(requestParameters: DefaultApiUserGetSignOutInfoRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userGetSignOutInfo(requestParameters.redirectUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Log in
     * @param {DefaultApiUserLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userLogin(requestParameters: DefaultApiUserLoginRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userLogin(requestParameters.message, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset encryption key to revoke all authorized codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userRevokeSession(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userRevokeSession(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an impersonation
     * @param {DefaultApiUserSSOCreateImpersonationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSSOCreateImpersonation(requestParameters: DefaultApiUserSSOCreateImpersonationRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userSSOCreateImpersonation(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get SSO Auth URL
     * @param {DefaultApiUserSSOGetAuthURLRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSSOGetAuthURL(requestParameters: DefaultApiUserSSOGetAuthURLRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userSSOGetAuthURL(requestParameters.codeVerifier, requestParameters.redirectUrl, requestParameters.state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get SSO config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSSOGetConfig(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userSSOGetConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all impersonations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSSOListImpersonations(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userSSOListImpersonations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set SSO config
     * @param {DefaultApiUserSSOSetConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSSOSetConfig(requestParameters: DefaultApiUserSSOSetConfigRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userSSOSetConfig(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Share current session and generate a sharing code
     * @param {DefaultApiUserShareSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userShareSession(requestParameters: DefaultApiUserShareSessionRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userShareSession(requestParameters.request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View the finished profiling result of a task
     * @summary View the result of a task
     * @param {DefaultApiViewProfilingSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public viewProfilingSingle(requestParameters: DefaultApiViewProfilingSingleRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).viewProfilingSingle(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }
}
